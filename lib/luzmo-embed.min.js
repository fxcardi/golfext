(function (g, f) {
  var hasExports = typeof exports === 'object';
  if (typeof define === "function" && define.amd) {
    define([], f);
  } else if (typeof module === "object" && module.exports) {
    module.exports = f();
  } else {
    var m = hasExports ? f() : f();
    var root = hasExports ? exports : g;
    for(var i in m) root[i] = m[i];
  }}(typeof self !== 'undefined' ? self : this, () => {
var exports = {};
var module = { exports };
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i6 = decorators.length - 1, decorator; i6 >= 0; i6--)
    if (decorator = decorators[i6])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

// libs/embed-libs/embed/src/index.ts
var src_exports2 = {};
__export(src_exports2, {
  LuzmoDashboard: () => LuzmoDashboard2,
  LuzmoEmbedDashboard: () => LuzmoEmbedDashboard,
  LuzmoVizItem: () => LuzmoVizItem
});
module.exports = __toCommonJS(src_exports2);

// node_modules/@lit/reactive-element/decorators/custom-element.js
var t = (t5) => (e7, o6) => {
  void 0 !== o6 ? o6.addInitializer(() => {
    customElements.define(t5, e7);
  }) : customElements.define(t5, e7);
};

// node_modules/@lit/reactive-element/css-tag.js
var t2 = globalThis;
var e = t2.ShadowRoot && (void 0 === t2.ShadyCSS || t2.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var s = Symbol();
var o = /* @__PURE__ */ new WeakMap();
var n = class {
  constructor(t5, e7, o6) {
    if (this._$cssResult$ = true, o6 !== s)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t5, this.t = e7;
  }
  get styleSheet() {
    let t5 = this.o;
    const s4 = this.t;
    if (e && void 0 === t5) {
      const e7 = void 0 !== s4 && 1 === s4.length;
      e7 && (t5 = o.get(s4)), void 0 === t5 && ((this.o = t5 = new CSSStyleSheet()).replaceSync(this.cssText), e7 && o.set(s4, t5));
    }
    return t5;
  }
  toString() {
    return this.cssText;
  }
};
var r = (t5) => new n("string" == typeof t5 ? t5 : t5 + "", void 0, s);
var i = (t5, ...e7) => {
  const o6 = 1 === t5.length ? t5[0] : e7.reduce((e8, s4, o7) => e8 + ((t6) => {
    if (true === t6._$cssResult$)
      return t6.cssText;
    if ("number" == typeof t6)
      return t6;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t6 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s4) + t5[o7 + 1], t5[0]);
  return new n(o6, t5, s);
};
var S = (s4, o6) => {
  if (e)
    s4.adoptedStyleSheets = o6.map((t5) => t5 instanceof CSSStyleSheet ? t5 : t5.styleSheet);
  else
    for (const e7 of o6) {
      const o7 = document.createElement("style"), n6 = t2.litNonce;
      void 0 !== n6 && o7.setAttribute("nonce", n6), o7.textContent = e7.cssText, s4.appendChild(o7);
    }
};
var c = e ? (t5) => t5 : (t5) => t5 instanceof CSSStyleSheet ? ((t6) => {
  let e7 = "";
  for (const s4 of t6.cssRules)
    e7 += s4.cssText;
  return r(e7);
})(t5) : t5;

// node_modules/@lit/reactive-element/reactive-element.js
var { is: i2, defineProperty: e2, getOwnPropertyDescriptor: r2, getOwnPropertyNames: h, getOwnPropertySymbols: o2, getPrototypeOf: n2 } = Object;
var a = globalThis;
var c2 = a.trustedTypes;
var l = c2 ? c2.emptyScript : "";
var p = a.reactiveElementPolyfillSupport;
var d = (t5, s4) => t5;
var u = { toAttribute(t5, s4) {
  switch (s4) {
    case Boolean:
      t5 = t5 ? l : null;
      break;
    case Object:
    case Array:
      t5 = null == t5 ? t5 : JSON.stringify(t5);
  }
  return t5;
}, fromAttribute(t5, s4) {
  let i6 = t5;
  switch (s4) {
    case Boolean:
      i6 = null !== t5;
      break;
    case Number:
      i6 = null === t5 ? null : Number(t5);
      break;
    case Object:
    case Array:
      try {
        i6 = JSON.parse(t5);
      } catch (t6) {
        i6 = null;
      }
  }
  return i6;
} };
var f = (t5, s4) => !i2(t5, s4);
var y = { attribute: true, type: String, converter: u, reflect: false, hasChanged: f };
Symbol.metadata ??= Symbol("metadata"), a.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
var b = class extends HTMLElement {
  static addInitializer(t5) {
    this._$Ei(), (this.l ??= []).push(t5);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t5, s4 = y) {
    if (s4.state && (s4.attribute = false), this._$Ei(), this.elementProperties.set(t5, s4), !s4.noAccessor) {
      const i6 = Symbol(), r7 = this.getPropertyDescriptor(t5, i6, s4);
      void 0 !== r7 && e2(this.prototype, t5, r7);
    }
  }
  static getPropertyDescriptor(t5, s4, i6) {
    const { get: e7, set: h3 } = r2(this.prototype, t5) ?? { get() {
      return this[s4];
    }, set(t6) {
      this[s4] = t6;
    } };
    return { get() {
      return e7?.call(this);
    }, set(s5) {
      const r7 = e7?.call(this);
      h3.call(this, s5), this.requestUpdate(t5, r7, i6);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t5) {
    return this.elementProperties.get(t5) ?? y;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d("elementProperties")))
      return;
    const t5 = n2(this);
    t5.finalize(), void 0 !== t5.l && (this.l = [...t5.l]), this.elementProperties = new Map(t5.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d("finalized")))
      return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d("properties"))) {
      const t6 = this.properties, s4 = [...h(t6), ...o2(t6)];
      for (const i6 of s4)
        this.createProperty(i6, t6[i6]);
    }
    const t5 = this[Symbol.metadata];
    if (null !== t5) {
      const s4 = litPropertyMetadata.get(t5);
      if (void 0 !== s4)
        for (const [t6, i6] of s4)
          this.elementProperties.set(t6, i6);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t6, s4] of this.elementProperties) {
      const i6 = this._$Eu(t6, s4);
      void 0 !== i6 && this._$Eh.set(i6, t6);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s4) {
    const i6 = [];
    if (Array.isArray(s4)) {
      const e7 = new Set(s4.flat(1 / 0).reverse());
      for (const s5 of e7)
        i6.unshift(c(s5));
    } else
      void 0 !== s4 && i6.push(c(s4));
    return i6;
  }
  static _$Eu(t5, s4) {
    const i6 = s4.attribute;
    return false === i6 ? void 0 : "string" == typeof i6 ? i6 : "string" == typeof t5 ? t5.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise((t5) => this.enableUpdating = t5), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t5) => t5(this));
  }
  addController(t5) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t5), void 0 !== this.renderRoot && this.isConnected && t5.hostConnected?.();
  }
  removeController(t5) {
    this._$EO?.delete(t5);
  }
  _$E_() {
    const t5 = /* @__PURE__ */ new Map(), s4 = this.constructor.elementProperties;
    for (const i6 of s4.keys())
      this.hasOwnProperty(i6) && (t5.set(i6, this[i6]), delete this[i6]);
    t5.size > 0 && (this._$Ep = t5);
  }
  createRenderRoot() {
    const t5 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S(t5, this.constructor.elementStyles), t5;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(true), this._$EO?.forEach((t5) => t5.hostConnected?.());
  }
  enableUpdating(t5) {
  }
  disconnectedCallback() {
    this._$EO?.forEach((t5) => t5.hostDisconnected?.());
  }
  attributeChangedCallback(t5, s4, i6) {
    this._$AK(t5, i6);
  }
  _$EC(t5, s4) {
    const i6 = this.constructor.elementProperties.get(t5), e7 = this.constructor._$Eu(t5, i6);
    if (void 0 !== e7 && true === i6.reflect) {
      const r7 = (void 0 !== i6.converter?.toAttribute ? i6.converter : u).toAttribute(s4, i6.type);
      this._$Em = t5, null == r7 ? this.removeAttribute(e7) : this.setAttribute(e7, r7), this._$Em = null;
    }
  }
  _$AK(t5, s4) {
    const i6 = this.constructor, e7 = i6._$Eh.get(t5);
    if (void 0 !== e7 && this._$Em !== e7) {
      const t6 = i6.getPropertyOptions(e7), r7 = "function" == typeof t6.converter ? { fromAttribute: t6.converter } : void 0 !== t6.converter?.fromAttribute ? t6.converter : u;
      this._$Em = e7, this[e7] = r7.fromAttribute(s4, t6.type), this._$Em = null;
    }
  }
  requestUpdate(t5, s4, i6) {
    if (void 0 !== t5) {
      if (i6 ??= this.constructor.getPropertyOptions(t5), !(i6.hasChanged ?? f)(this[t5], s4))
        return;
      this.P(t5, s4, i6);
    }
    false === this.isUpdatePending && (this._$ES = this._$ET());
  }
  P(t5, s4, i6) {
    this._$AL.has(t5) || this._$AL.set(t5, s4), true === i6.reflect && this._$Em !== t5 && (this._$Ej ??= /* @__PURE__ */ new Set()).add(t5);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t6) {
      Promise.reject(t6);
    }
    const t5 = this.scheduleUpdate();
    return null != t5 && await t5, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [t7, s5] of this._$Ep)
          this[t7] = s5;
        this._$Ep = void 0;
      }
      const t6 = this.constructor.elementProperties;
      if (t6.size > 0)
        for (const [s5, i6] of t6)
          true !== i6.wrapped || this._$AL.has(s5) || void 0 === this[s5] || this.P(s5, this[s5], i6);
    }
    let t5 = false;
    const s4 = this._$AL;
    try {
      t5 = this.shouldUpdate(s4), t5 ? (this.willUpdate(s4), this._$EO?.forEach((t6) => t6.hostUpdate?.()), this.update(s4)) : this._$EU();
    } catch (s5) {
      throw t5 = false, this._$EU(), s5;
    }
    t5 && this._$AE(s4);
  }
  willUpdate(t5) {
  }
  _$AE(t5) {
    this._$EO?.forEach((t6) => t6.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t5)), this.updated(t5);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t5) {
    return true;
  }
  update(t5) {
    this._$Ej &&= this._$Ej.forEach((t6) => this._$EC(t6, this[t6])), this._$EU();
  }
  updated(t5) {
  }
  firstUpdated(t5) {
  }
};
b.elementStyles = [], b.shadowRootOptions = { mode: "open" }, b[d("elementProperties")] = /* @__PURE__ */ new Map(), b[d("finalized")] = /* @__PURE__ */ new Map(), p?.({ ReactiveElement: b }), (a.reactiveElementVersions ??= []).push("2.0.4");

// node_modules/@lit/reactive-element/decorators/property.js
var o3 = { attribute: true, type: String, converter: u, reflect: false, hasChanged: f };
var r3 = (t5 = o3, e7, r7) => {
  const { kind: n6, metadata: i6 } = r7;
  let s4 = globalThis.litPropertyMetadata.get(i6);
  if (void 0 === s4 && globalThis.litPropertyMetadata.set(i6, s4 = /* @__PURE__ */ new Map()), s4.set(r7.name, t5), "accessor" === n6) {
    const { name: o6 } = r7;
    return { set(r8) {
      const n7 = e7.get.call(this);
      e7.set.call(this, r8), this.requestUpdate(o6, n7, t5);
    }, init(e8) {
      return void 0 !== e8 && this.P(o6, void 0, t5), e8;
    } };
  }
  if ("setter" === n6) {
    const { name: o6 } = r7;
    return function(r8) {
      const n7 = this[o6];
      e7.call(this, r8), this.requestUpdate(o6, n7, t5);
    };
  }
  throw Error("Unsupported decorator location: " + n6);
};
function n3(t5) {
  return (e7, o6) => "object" == typeof o6 ? r3(t5, e7, o6) : ((t6, e8, o7) => {
    const r7 = e8.hasOwnProperty(o7);
    return e8.constructor.createProperty(o7, r7 ? { ...t6, wrapped: true } : t6), r7 ? Object.getOwnPropertyDescriptor(e8, o7) : void 0;
  })(t5, e7, o6);
}

// node_modules/@lit/reactive-element/decorators/state.js
function r4(r7) {
  return n3({ ...r7, state: true, attribute: false });
}

// node_modules/@lit/reactive-element/decorators/base.js
var e3 = (e7, t5, c4) => (c4.configurable = true, c4.enumerable = true, Reflect.decorate && "object" != typeof t5 && Object.defineProperty(e7, t5, c4), c4);

// node_modules/@lit/reactive-element/decorators/query.js
function e4(e7, r7) {
  return (n6, s4, i6) => {
    const o6 = (t5) => t5.renderRoot?.querySelector(e7) ?? null;
    if (r7) {
      const { get: e8, set: r8 } = "object" == typeof s4 ? n6 : i6 ?? (() => {
        const t5 = Symbol();
        return { get() {
          return this[t5];
        }, set(e9) {
          this[t5] = e9;
        } };
      })();
      return e3(n6, s4, { get() {
        let t5 = e8.call(this);
        return void 0 === t5 && (t5 = o6(this), (null !== t5 || this.hasUpdated) && r8.call(this, t5)), t5;
      } });
    }
    return e3(n6, s4, { get() {
      return o6(this);
    } });
  };
}

// libs/embed-libs/shared-embed/src/lib/helpers/error.ts
var _handleError = (errorMessage, parameters) => {
  let message = "The dashboard component encountered an error";
  if (typeof parameters?.dashboardId === "string") {
    message += ` for dashboard with id ${parameters.dashboardId}`;
  }
  if (typeof parameters?.dashboardSlug === "string") {
    message += ` for dashboard with slug ${parameters.dashboardSlug}`;
  }
  if (typeof parameters?.container === "string") {
    message += ` in container ${parameters.container}`;
  }
  if (errorMessage) {
    message += `:
${errorMessage}`;
    console.warn(message);
  }
};

// libs/embed-libs/shared-embed/src/lib/helpers/browser-check.ts
var _browserCheck = (dashboardComponent) => {
  let hasError = false;
  let errorMessage = "";
  const document_ = document.body || document.documentElement;
  const style = document_.style;
  const browserCheck = {
    svg: !!("createElementNS" in document && document.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect),
    flexbox: style.webkitFlexWrap === "" || style.flexWrap === "",
    postMessage: !!window.postMessage
  };
  const browserCheckKeys = ["svg", "flexbox", "postMessage"];
  for (const key of browserCheckKeys) {
    if (!browserCheck[key]) {
      hasError = true;
      dashboardComponent.browserNotSupported = dashboardComponent.browserNotSupported || [];
      dashboardComponent.browserNotSupported.push(key);
      errorMessage += `Your browser does not support: ${key}
`;
    }
  }
  const ua = window.navigator.userAgent;
  const msie = ua.includes("MSIE");
  const trident = ua.includes("Trident/");
  if (msie || trident) {
    hasError = true;
    errorMessage = "IE is not supported.";
  }
  if (hasError) {
    _handleError(errorMessage);
  }
};

// libs/embed-libs/shared-embed/src/lib/helpers/default-parameters.ts
var DEFAULT_PARAMETERS = {
  appServer: "https://app.luzmo.com/",
  apiHost: "https://api.luzmo.com/",
  dashboardId: null,
  dashboardSlug: null,
  container: null,
  key: null,
  token: null,
  language: "auto",
  qeVersion: null,
  editMode: null,
  screenMode: null,
  switchScreenModeOnResize: true,
  itemId: null,
  mainColor: "",
  accentColor: "",
  itemDimensions: {
    width: "auto",
    height: "auto"
  },
  loaderBackground: "#f9f9f9",
  loaderFontColor: "#5a5a5a",
  loaderSpinnerColor: "rgba(255, 165, 0, 0.7)",
  loaderSpinnerBackground: "rgba(169, 169, 169, 0.14)",
  timezoneId: null,
  contextId: null
};

// libs/embed-libs/shared-embed/src/lib/helpers/extents.ts
var EXTENTS = [
  { mode: "mobile", width: [150, 767] },
  { mode: "tablet", width: [768, 1199] },
  { mode: "desktop", width: [1200, 1599] },
  { mode: "largeScreen", width: [1600, 9999] },
  { mode: "fixed", width: [] }
];

// libs/embed-libs/shared-embed/src/lib/helpers/translations.ts
var TRANSLATIONS = {
  initializing: { en: "Initializing...", nl: "Laden...", fr: "Chargement..." },
  errorDashboard: {
    en: "Oops, we could not load this dashboard!",
    nl: "Oeps, we konden het dashboard niet laden.",
    fr: "Le chargement a echou\xE9."
  },
  errorItem: {
    en: "Oops, we could not load this item!",
    nl: "Oeps, we konden de grafiek niet laden.",
    fr: "Le chargement a echou\xE9."
  }
};
var translations_default = TRANSLATIONS;

// libs/embed-libs/shared-embed/src/lib/helpers/utils.ts
var addTrailingSlash = (serverUrl) => {
  if (!serverUrl) {
    return "";
  }
  return serverUrl.endsWith("/") ? serverUrl : `${serverUrl}/`;
};
var removeTrailingSlash = (serverUrl) => {
  if (!serverUrl) {
    return "";
  }
  return serverUrl.endsWith("/") ? serverUrl.slice(0, -1) : serverUrl;
};
var formatDashboardList = (dashboards, integrationId, user, dashboardComponent) => {
  const combineRights = (securable, user2) => {
    const matchingUser = securable.users.find((u3) => u3.id === user2.id);
    const securableAccessRights = matchingUser && matchingUser.userAccessRight ? {
      flagRead: matchingUser.userAccessRight.flagRead,
      flagUse: matchingUser.userAccessRight.flagUse,
      flagModify: matchingUser.userAccessRight.flagModify,
      flagOwn: matchingUser.userAccessRight.flagOwn
    } : {
      flagRead: false,
      flagUse: false,
      flagModify: false,
      flagOwn: false
    };
    const groups = securable.groups.filter(
      (group) => user2.userGroups.includes(group.id) || group.public === true
    );
    const groupsAccess = groups.map((group) => {
      if (group.groupAccessRight) {
        return group.groupAccessRight;
      }
    });
    for (const groupAccess of groupsAccess) {
      if (!securableAccessRights.flagRead && groupAccess.flagRead) {
        securableAccessRights.flagRead = groupAccess.flagRead;
      }
      if (!securableAccessRights.flagUse && groupAccess.flagUse) {
        securableAccessRights.flagUse = groupAccess.flagUse;
      }
      if (!securableAccessRights.flagModify && groupAccess.flagModify) {
        securableAccessRights.flagModify = groupAccess.flagModify;
      }
      if (!securableAccessRights.flagOwn && groupAccess.flagOwn) {
        securableAccessRights.flagOwn = groupAccess.flagOwn;
      }
    }
    const integrationsAccess = securable.integrations?.length > 0 ? securable.integrations.map((integration) => {
      if (integration.integrationAccessRight) {
        return integration.integrationAccessRight;
      }
    }) : [];
    for (const integrationAccess of integrationsAccess) {
      if (!securableAccessRights.flagRead && integrationAccess.flagRead) {
        securableAccessRights.flagRead = integrationAccess.flagRead;
      }
      if (!securableAccessRights.flagUse && integrationAccess.flagUse) {
        securableAccessRights.flagUse = integrationAccess.flagUse;
      }
      if (!securableAccessRights.flagModify && integrationAccess.flagModify) {
        securableAccessRights.flagModify = integrationAccess.flagModify;
      }
    }
    return securableAccessRights;
  };
  const localize = (item, locale) => {
    if (item === null || item === void 0) {
      return "";
    }
    if (typeof item !== "object" || Object.keys(item).length === 0) {
      if (typeof item === "object" && Object.keys(item).length === 0) {
        return "";
      }
      return item;
    }
    let localizedItem;
    localizedItem = locale && item[locale] ? item[locale] : item[Object.keys(item)[0]];
    if (localizedItem === void 0 || localizedItem === null) {
      localizedItem = "";
    }
    return localizedItem;
  };
  const treatedDashboards = [];
  for (const dashboard of dashboards) {
    const treatedDashboard = {
      accessibleBy: [],
      accessRights: combineRights(dashboard, user),
      id: dashboard.id,
      modifiedAt: dashboard.modified_at,
      name: localize(dashboard.name, dashboardComponent.language),
      slug: null,
      tags: dashboard.tags.map((t5) => t5.tag).sort((t1, t22) => t1.localeCompare(t22))
    };
    const currentIntegration = dashboard.integrations.find(
      (i6) => i6.id === integrationId
    );
    if (currentIntegration?.integrationAccessRight?.slug) {
      treatedDashboard.slug = currentIntegration.integrationAccessRight.slug;
    }
    const users = dashboard.users.map((u3) => ({
      model: "User",
      id: u3.id,
      name: localize(u3.name, user.locale_id)
    }));
    const groups = dashboard.groups.map((g2) => ({
      model: "Group",
      id: g2.id,
      name: localize(g2.name, user.locale_id) || {}
    }));
    const integrations = dashboard.integrations.map((i6) => ({
      model: "Integration",
      id: i6.id,
      name: localize(i6.name, user.locale_id) || {}
    }));
    treatedDashboard.accessibleBy = [...users, ...groups, ...integrations];
    treatedDashboards.push(treatedDashboard);
  }
  return treatedDashboards;
};
var VERSION = "0.0.0-unknown-luzmo";
var sanitizeUrl = (url) => {
  const invalidPrototcolRegex = /^(%20|\s)*(javascript|data)/im;
  const ctrlCharactersRegex = /[^\u0020-\u007E]/gim;
  const urlSchemeRegex = /^([^:]+):/gm;
  const relativeFirstCharacters = /* @__PURE__ */ new Set([".", "/"]);
  const isRelativeUrlWithoutProtocol = (relativeUrl) => relativeFirstCharacters.has(relativeUrl[0]);
  if (!url) {
    return "about:blank";
  }
  const sanitizedUrl = url.replaceAll(ctrlCharactersRegex, "").trim();
  if (isRelativeUrlWithoutProtocol(sanitizedUrl)) {
    return sanitizedUrl;
  }
  const urlSchemeParseResults = sanitizedUrl.match(urlSchemeRegex);
  if (!urlSchemeParseResults) {
    return sanitizedUrl;
  }
  const urlScheme = urlSchemeParseResults[0];
  if (invalidPrototcolRegex.test(urlScheme)) {
    return "about:blank";
  }
  return sanitizedUrl;
};
var cloneDeep = (obj) => JSON.parse(JSON.stringify(obj));
var isObject = (o6) => o6 && typeof o6 === "object";
var defaultsDeep = (target, defaults) => {
  Object.entries(defaults).forEach(([k2, v2]) => {
    if (k2 in target) {
      if (target[k2] === void 0) {
        target[k2] = v2;
      } else {
        target[k2] = isObject(v2) ? defaultsDeep(
          target[k2],
          v2
        ) : target[k2];
      }
    } else {
      target[k2] = v2;
    }
  });
  return target;
};
var uuidv4 = () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replaceAll(/[xy]/g, function(c4) {
  const r7 = Math.random() * 16 | 0;
  const v2 = c4 == "x" ? r7 : r7 & 3 | 8;
  return v2.toString(16);
});

// libs/embed-libs/shared-embed/src/lib/helpers/iframe-url.ts
var createIframeUrl = (dashboardContent) => {
  const searchString = [];
  const {
    appServer,
    language,
    qeVersion,
    loaderBackground,
    loaderSpinnerColor,
    loaderSpinnerBackground,
    loaderFontColor,
    screenMode,
    key,
    token,
    timezoneId,
    itemEmbedding,
    itemDimensions,
    dashboardId,
    dashboardSlug,
    itemId,
    mainColor,
    accentColor,
    editMode
  } = dashboardContent.params;
  if (language && language !== "auto") {
    searchString.push("language=" + language);
  }
  if (qeVersion) {
    searchString.push(`qe_version=${qeVersion}`);
  }
  if (loaderBackground) {
    searchString.push(`ldrbg=${loaderBackground}`);
  }
  if (loaderFontColor) {
    searchString.push(`ldrftclr=${loaderFontColor}`);
  }
  if (loaderSpinnerColor) {
    searchString.push(`ldrspclr=${loaderSpinnerColor}`);
  }
  if (loaderSpinnerBackground) {
    searchString.push(`ldrspbg=${loaderSpinnerBackground}`);
  }
  if (mainColor) {
    searchString.push(`mainColor=${mainColor}`);
  }
  if (accentColor) {
    searchString.push(`accentColor=${accentColor}`);
  }
  if (screenMode && screenMode !== "auto") {
    searchString.push("screenMode=" + screenMode);
  }
  if (timezoneId) {
    searchString.push("timezoneId=" + timezoneId);
  }
  if (itemEmbedding && itemDimensions && itemDimensions.width) {
    searchString.push("width=" + itemDimensions.width);
  }
  if (itemEmbedding && itemDimensions && itemDimensions.height) {
    searchString.push("height=" + itemDimensions.height);
  }
  if (editMode) {
    searchString.push("editMode=" + editMode);
  }
  const keyTokenUrlAnchor = key && token ? "#" + key + ":" + token : "";
  searchString.push("version=" + (dashboardContent.libVersion || VERSION));
  const iframeUrl = itemEmbedding ? `${appServer}i/${dashboardId || dashboardSlug}/${itemId}?${encodeURIComponent(
    searchString.join("&")
  )}${keyTokenUrlAnchor}` : `${appServer}i/${dashboardId || dashboardSlug}?${encodeURIComponent(
    searchString.join("&")
  )}${keyTokenUrlAnchor}`;
  return sanitizeUrl(iframeUrl);
};

// libs/embed-libs/shared-embed/src/lib/helpers/get-loader.ts
var getLoader = (dashboardComponent) => {
  let errorMsg;
  if (dashboardComponent.params.error || dashboardComponent.browserNotSupported.length > 0) {
    dashboardComponent.params.error = true;
    if (dashboardComponent.browserNotSupported) {
      errorMsg = "Browser is not supported.";
    }
  }
  const loadingMsg = translations_default.initializing[dashboardComponent.params.language] || translations_default.initializing.en;
  return dashboardComponent.browserNotSupported || dashboardComponent.params.error ? { loadingMsg, errorMsg } : { loadingMsg, errorMsg: "" };
};

// libs/embed-libs/shared-embed/src/lib/helpers/promise-dispatch.ts
function resolvePromise(dashboardComponent, requestId, data) {
  if (dashboardComponent.promises[requestId]) {
    dashboardComponent.promises[requestId].resolve(data);
    delete dashboardComponent.promises[requestId];
  }
}
function rejectPromise(dashboardComponent, requestId, data) {
  if (dashboardComponent.promises[requestId]) {
    dashboardComponent.promises[requestId].reject(data);
    delete dashboardComponent.promises[requestId];
  }
}

// libs/embed-libs/shared-embed/src/lib/helpers/styles.ts
function containerStyles(dashboardComponent) {
  const styles = {};
  if (dashboardComponent.params.loaderBackground && !dashboardComponent.iframeLoaded) {
    styles.background = dashboardComponent.params.loaderBackground;
  }
  return styles;
}
function containerLoaderStyles(dashboardComponent) {
  const height = dashboardComponent.params.itemDimensions?.height || DEFAULT_PARAMETERS.itemDimensions.height;
  const chartHeightDefined = dashboardComponent.params.itemEmbedding && height !== "auto";
  const display = dashboardComponent.iframeLoaded ? "none" : "";
  return {
    display,
    height: `${chartHeightDefined ? height : dashboardComponent.minHeight}px`
  };
}
function loaderStyles(dashboardComponent) {
  const background = dashboardComponent.params.loaderBackground || DEFAULT_PARAMETERS.loaderBackground;
  if (dashboardComponent.params.itemEmbedding) {
    dashboardComponent.loaderSize = 24;
    dashboardComponent.borderWidth = 4;
    dashboardComponent.minHeight = 200;
    const width = dashboardComponent.params.itemDimensions?.width || DEFAULT_PARAMETERS.itemDimensions.width;
    const height = dashboardComponent.params.itemDimensions?.height || DEFAULT_PARAMETERS.itemDimensions.height;
    const chartWidthDefined = width !== "auto";
    const chartHeightDefined = height !== "auto";
    return {
      background,
      width: chartWidthDefined ? `${width}px` : "100%",
      height: `${chartHeightDefined ? height : "200"}px`,
      "min-height": chartHeightDefined ? "" : "200px"
    };
  }
  return {
    background
  };
}
function plStyles(dashboardComponent) {
  const {
    loaderSpinnerColor: defaultSpinnerColor,
    loaderSpinnerBackground: defaultSpinnerBackground
  } = DEFAULT_PARAMETERS;
  const spinnerColorBorder = generateBorderStyle(
    dashboardComponent.borderWidth,
    dashboardComponent.params.loaderSpinnerColor || defaultSpinnerColor
  );
  const spinnerBackgroundBorder = generateBorderStyle(
    dashboardComponent.borderWidth,
    dashboardComponent.params.loaderSpinnerBackground || defaultSpinnerBackground
  );
  const size = `${dashboardComponent.loaderSize}px`;
  return {
    "border-top": spinnerColorBorder,
    "border-right": spinnerColorBorder,
    "border-bottom": spinnerBackgroundBorder,
    "border-left": spinnerBackgroundBorder,
    width: size,
    height: size
  };
}
function lcStyles(dashboardComponent) {
  const height = dashboardComponent.params.itemDimensions?.height || DEFAULT_PARAMETERS.itemDimensions.height;
  const chartHeightDefined = dashboardComponent.params.itemEmbedding && height !== "auto";
  const getPaddingStr = (value) => `${(value - dashboardComponent.loaderSize - 32) / 2}px`;
  const verticalPadding = dashboardComponent.params.itemId ? chartHeightDefined ? getPaddingStr(Number.parseInt(`${height}`, 10)) : getPaddingStr(dashboardComponent.minHeight) : "128px";
  return {
    padding: `${verticalPadding} 16px`
  };
}
function calculateIframeStyles(dashboardComponent) {
  const height = dashboardComponent.params.itemDimensions?.height || DEFAULT_PARAMETERS.itemDimensions.height;
  const width = dashboardComponent.params.itemDimensions?.width || DEFAULT_PARAMETERS.itemDimensions.width;
  if (dashboardComponent.params.itemEmbedding && height !== "auto") {
    dashboardComponent.iframeHeight = `${height}px`;
  } else if (dashboardComponent.params.itemEmbedding) {
    dashboardComponent.iframeHeight = "200px";
  } else if (["editFull", "editLimited"].includes(dashboardComponent.params.editMode)) {
    dashboardComponent.iframeHeight = "100%";
  } else {
    dashboardComponent.iframeHeight = "400px";
  }
  dashboardComponent.iframeWidth = dashboardComponent.params.itemEmbedding && width !== "auto" ? `${width}px` : "100%";
  const styles = {
    height: dashboardComponent.iframeHeight,
    width: dashboardComponent.iframeWidth
  };
  if (dashboardComponent.iframeLoaded) {
    styles.opacity = 1;
  } else if (dashboardComponent.error) {
    styles.opacity = 1;
    styles.width = "100%";
    styles.height = "400px";
  } else {
    styles.opacity = 0;
  }
  return styles;
}
function generateBorderStyle(borderWidth, color) {
  return `${borderWidth}px solid ${color}`;
}

// libs/embed-libs/shared-embed/src/lib/helpers/update-iframe-url.ts
var updateIframeUrl = (iframe, iframeUrl) => {
  if (iframe?.contentWindow) {
    iframe.contentWindow.location.replace(iframeUrl);
  }
};

// libs/embed-libs/shared-embed/src/lib/methods/export-dashboard.ts
var exportDashboard = (dashboardComponent, iframe, format) => {
  const requestId = uuidv4();
  if (iframe?.contentWindow) {
    iframe.contentWindow.postMessage(
      {
        action: "exportDashboard",
        format: format || "png",
        _version: dashboardComponent.libVersion,
        requestId
      },
      "*"
    );
    return new Promise((resolve, reject) => {
      dashboardComponent.promises[requestId] = { resolve, reject };
      setTimeout(() => {
        if (dashboardComponent.promises[requestId]) {
          const errorMessage = "exportDashboard request timed out.";
          dashboardComponent.promises[requestId].reject(
            new Error(errorMessage)
          );
          delete dashboardComponent.promises[requestId];
        }
      }, 12e5);
    });
  }
  return Promise.reject(new Error("Cannot retrieve contentWindow."));
};

// libs/embed-libs/shared-embed/src/lib/methods/get-accessible-dashboards.ts
var getAccessibleDashboards = (dashboardComponent) => {
  if ((dashboardComponent.currentAuthKey ?? dashboardComponent.authKey) && (dashboardComponent.currentAuthToken ?? dashboardComponent.authToken)) {
    const fetchUser = new Promise((resolve, reject) => {
      void (() => {
        try {
          const responsePromise = window.fetch(
            // With experimental=true URLs remove the trailing slash, since the web component expects them to not have it.
            // Fixes incorrect url with experimental=true
            `${addTrailingSlash(dashboardComponent.params.apiHost)}0.1.0/authorization`,
            {
              method: "POST",
              mode: "cors",
              cache: "no-cache",
              headers: { "Content-Type": "application/json" },
              redirect: "follow",
              body: JSON.stringify({
                action: "get",
                version: "0.1.0",
                key: dashboardComponent.currentAuthKey ?? dashboardComponent.authKey,
                token: dashboardComponent.currentAuthToken ?? dashboardComponent.authToken,
                find: {
                  where: { id: dashboardComponent.authKey },
                  attributes: ["id", "integration_id"],
                  include: [
                    {
                      model: "User",
                      attributes: ["id", "name", "locale_id"],
                      include: [{ model: "Group" }]
                    }
                  ]
                }
              })
            }
          );
          responsePromise.then((response) => response.json()).then((data) => {
            if (!data || !data.rows || data.rows.length === 0 || !data.rows[0].user) {
              reject("Authorization failed, please check authKey and authToken. If the problem persists, please contact support@luzmo.com.");
            } else {
              data.rows[0].user.userGroups = data.rows[0].user.groups.map(
                (group) => group.id
              );
              delete data.rows[0].user.groups;
              resolve({
                integrationId: data.rows[0].integration_id,
                user: data.rows[0].user
              });
            }
          });
        } catch (error) {
          reject(error);
        }
      })();
    });
    return new Promise((resolve, reject) => void (() => {
      try {
        fetchUser.then((authorizationData) => {
          const responsePromise = window.fetch(
            // With experimental=true URLs remove the trailing slash, since the web component expects them to not have it.
            // Fixes incorrect url with experimental=true
            `${addTrailingSlash(dashboardComponent.params.apiHost)}0.1.0/securable`,
            {
              method: "POST",
              mode: "cors",
              cache: "no-cache",
              headers: { "Content-Type": "application/json" },
              redirect: "follow",
              body: JSON.stringify({
                action: "get",
                version: "0.1.0",
                key: dashboardComponent.currentAuthKey ?? dashboardComponent.authKey,
                token: dashboardComponent.currentAuthToken ?? dashboardComponent.authToken,
                find: {
                  where: { type: "dashboard", is_variant: false },
                  attributes: ["id", "name", "modified_at"],
                  order: [["modified_at", "desc"]],
                  include: [
                    { model: "Tag", attributes: ["tag"] },
                    { model: "User", attributes: ["id", "name"] },
                    {
                      model: "Group",
                      attributes: ["id", "name", "public"]
                    },
                    { model: "Integration", attributes: ["id", "name"] }
                  ]
                }
              })
            }
          );
          responsePromise.then((response) => response.json()).then((data) => {
            const dashboardList = data.rows.length > 0 ? formatDashboardList(
              data.rows,
              authorizationData.integrationId,
              authorizationData.user,
              dashboardComponent
            ) : [];
            resolve(dashboardList);
          });
        }).catch((error) => {
          reject(error);
        });
      } catch (error) {
        reject(error);
      }
    })());
  }
  throw new Error("No authKey or authToken found in the luzmo-dashboard component.");
};

// libs/embed-libs/shared-embed/src/lib/methods/get-data.ts
var getData = (dashboardComponent, iframe, itemId) => {
  if (iframe?.contentWindow) {
    const requestId = uuidv4();
    iframe.contentWindow.postMessage(
      {
        action: "getData",
        id: itemId,
        _version: dashboardComponent.libVersion,
        requestId
      },
      "*"
    );
    return new Promise((resolve, reject) => {
      dashboardComponent.promises[requestId] = { resolve, reject };
      setTimeout(() => {
        if (dashboardComponent.promises[requestId]) {
          const errorMessage = "getData request timed out.";
          dashboardComponent.promises[requestId].reject(
            new Error(errorMessage)
          );
          delete dashboardComponent.promises[requestId];
        }
      }, 2e3);
    });
  }
  return Promise.reject(new Error("Cannot retrieve contentWindow."));
};

// libs/embed-libs/shared-embed/src/lib/methods/get-filters.ts
var getFilters = (dashboardComponent, iframe) => {
  if (iframe?.contentWindow) {
    const requestId = uuidv4();
    iframe.contentWindow.postMessage(
      { action: "getFilters", _version: dashboardComponent.libVersion, requestId },
      "*"
    );
    return new Promise((resolve, reject) => {
      dashboardComponent.promises[requestId] = { resolve, reject };
      setTimeout(() => {
        if (dashboardComponent.promises[requestId]) {
          const errorMessage = "getFilters request timed out.";
          dashboardComponent.promises[requestId].reject(
            new Error(errorMessage)
          );
          delete dashboardComponent.promises[requestId];
        }
      }, 2e3);
    });
  }
  return Promise.reject(new Error("Cannot retrieve contentWindow."));
};

// libs/embed-libs/shared-embed/src/lib/methods/refresh-data.ts
var refreshData = (dashboardComponent, iframe, itemId) => {
  if (iframe) {
    iframe.contentWindow.postMessage(
      {
        action: "refreshData",
        id: itemId ?? null,
        _version: dashboardComponent.libVersion
      },
      "*"
    );
    return Promise.resolve();
  }
  return Promise.reject(new Error("Cannot retrieve contentWindow."));
};

// libs/embed-libs/shared-embed/src/lib/methods/reload-dashboard.ts
var reloadDashboard = (dashboardComponent, iframe) => {
  if (iframe) {
    iframe.contentWindow.postMessage(
      { action: "reloadDashboard", _version: dashboardComponent.libVersion },
      "*"
    );
    return Promise.resolve();
  }
  return Promise.reject(new Error("Cannot retrieve contentWindow."));
};

// libs/embed-libs/shared-embed/src/lib/methods/set-authorization.ts
var setAuthorization = (dashboardComponent, iframe, key, token) => {
  if (iframe) {
    iframe.contentWindow.postMessage(
      {
        action: "setAuthorization",
        key,
        token,
        _version: dashboardComponent.libVersion
      },
      "*"
    );
    return Promise.resolve();
  }
  return Promise.reject(new Error("Cannot retrieve contentWindow."));
};

// libs/embed-libs/shared-embed/src/lib/methods/set-edit-mode.ts
var setEditMode = (dashboardComponent, iframe, editMode) => {
  if (iframe && iframe.contentWindow) {
    const requestId = uuidv4();
    if (dashboardComponent.params.editMode === editMode) {
      return Promise.reject(
        new Error("editMode parameter is currently already set to " + editMode)
      );
    } else if (editMode !== "editFull" && editMode !== "editLimited" && editMode !== "view") {
      return Promise.reject(
        new Error(
          "The editMode parameter must be one of the following values: 'editFull', 'editLimited' or 'view'."
        )
      );
    }
    iframe.contentWindow.postMessage(
      {
        action: "setEditMode",
        editMode,
        _version: dashboardComponent.libVersion,
        requestId
      },
      "*"
    );
    return new Promise((resolve, reject) => {
      dashboardComponent.promises[requestId] = { resolve, reject };
    });
  }
  return Promise.reject(new Error("Cannot retrieve contentWindow."));
};

// libs/embed-libs/shared-embed/src/lib/methods/set-filters.ts
var setFilters = (dashboardComponent, iframe, itemId, filters) => {
  if (iframe) {
    const requestId = uuidv4();
    iframe.contentWindow.postMessage(
      {
        action: "setFilters",
        itemId,
        filters,
        _version: dashboardComponent.libVersion,
        requestId
      },
      "*"
    );
    return new Promise((resolve, reject) => {
      dashboardComponent.promises[requestId] = { resolve, reject };
      setTimeout(() => {
        if (dashboardComponent.promises[requestId]) {
          const errorMessage = "setFilters request timed out.";
          dashboardComponent.promises[requestId].reject(
            new Error(errorMessage)
          );
          delete dashboardComponent.promises[requestId];
        }
      }, 2e3);
    });
  }
  return Promise.reject();
};

// libs/embed-libs/shared-embed/src/lib/methods/set-preview.ts
var setPreview = (dashboardComponent, iframe, preview) => {
  if (iframe) {
    const requestId = uuidv4();
    iframe.contentWindow.postMessage(
      {
        action: "setPreview",
        preview,
        requestId,
        _version: dashboardComponent.libVersion
      },
      "*"
    );
    return new Promise((resolve, reject) => {
      dashboardComponent.promises[requestId] = { resolve, reject };
      setTimeout(() => {
        if (dashboardComponent.promises[requestId]) {
          const errorMessage = "setPreview request timed out.";
          dashboardComponent.promises[requestId].reject(
            new Error(errorMessage)
          );
          delete dashboardComponent.promises[requestId];
        }
      }, 2e3);
    });
  }
  return Promise.reject(new Error("Cannot retrieve contentWindow."));
};

// libs/embed-libs/shared-embed/src/lib/service/calculate-dimensions.ts
var _setCalculatedDimensions = (dashboardComponent) => {
  if (!dashboardComponent.dimensions) {
    dashboardComponent.params.error = true;
    _handleError("Got no valid dimensions.", dashboardComponent.params);
    return;
  }
  const dashboardDimensionKeys = Object.keys(
    dashboardComponent.dimensions
  );
  const availableScreenModeExtents = [];
  let currentMode;
  let currentWidth = 0;
  let currentHeight = 0;
  if (!dashboardComponent.params.switchScreenModeOnResize && dashboardComponent.currentScreenMode) {
    dashboardComponent.params.screenMode = dashboardComponent.currentScreenMode;
  }
  if (dashboardComponent.dimensions && dashboardDimensionKeys?.[0] === "fixed") {
    currentMode = "fixed";
    currentWidth = dashboardComponent.dimensions.fixed[0];
    currentHeight = dashboardComponent.dimensions.fixed[1];
  } else {
    const screenModes = [
      "mobile",
      "tablet",
      "desktop",
      "largeScreen"
    ];
    if (dashboardComponent.params.itemEmbedding) {
      const [firstMatch] = dashboardDimensionKeys;
      let match = cloneDeep(firstMatch);
      for (const screenMode of screenModes) {
        const found = dashboardDimensionKeys.find((key) => key === screenMode);
        if (found) {
          match = cloneDeep(found);
        } else {
          dashboardComponent.dimensions[screenMode] = dashboardComponent.dimensions[match];
        }
      }
    }
    for (const key of dashboardDimensionKeys) {
      if (screenModes.includes(key)) {
        const screenMode = EXTENTS.find((extent) => extent.mode === key);
        availableScreenModeExtents.push({
          ...screenMode,
          height: dashboardComponent.dimensions[key][1] || 50
        });
      }
    }
    if (!availableScreenModeExtents.map((screenModeExtent) => screenModeExtent.mode).includes(dashboardComponent.params.screenMode)) {
      dashboardComponent.params.screenMode = "auto";
    }
    if (dashboardComponent.params.screenMode === "auto") {
      availableScreenModeExtents.sort(
        (a3, b3) => screenModes.indexOf(a3.mode) - screenModes.indexOf(b3.mode)
      );
      for (const screenModeExtent of availableScreenModeExtents) {
        const [screenModeExtentMinWidth, screenModeExtentMaxWidth] = screenModeExtent.width;
        if (dashboardComponent.params.itemEmbedding && dashboardComponent.params.itemDimensions && dashboardComponent.params.itemDimensions.width !== "auto" && dashboardComponent.params.itemDimensions.height === "auto") {
          if (screenModeExtentMinWidth < dashboardComponent.params.itemDimensions.width) {
            currentMode = screenModeExtent.mode;
            currentWidth = Number.parseInt(
              dashboardComponent.params.itemDimensions.width,
              10
            );
            currentHeight = dashboardComponent.dimensions[currentMode][1];
          }
        } else {
          if (screenModeExtentMinWidth < dashboardComponent.containerWidth) {
            currentMode = screenModeExtent.mode;
            if (dashboardComponent.params.itemEmbedding) {
              currentWidth = dashboardComponent.params.itemDimensions?.width && dashboardComponent.params.itemDimensions?.width !== "auto" ? Number.parseInt(
                dashboardComponent.params.itemDimensions.width,
                10
              ) : Math.min(
                dashboardComponent.containerWidth,
                screenModeExtentMaxWidth
              );
              currentHeight = dashboardComponent.params.itemDimensions?.height && dashboardComponent.params.itemDimensions?.height !== "auto" ? Number.parseInt(
                dashboardComponent.params.itemDimensions.height,
                10
              ) : dashboardComponent.dimensions[currentMode][1];
              if (dashboardComponent.params.itemDimensions && dashboardComponent.params.itemDimensions.width !== "auto" && dashboardComponent.params.itemDimensions.height === "auto") {
                currentWidth = Number.parseInt(
                  dashboardComponent.params.itemDimensions.width,
                  10
                );
                currentHeight = dashboardComponent.dimensions[currentMode][1];
              }
            } else {
              currentWidth = Math.max(
                Math.min(
                  screenModeExtentMaxWidth,
                  dashboardComponent.containerWidth
                ),
                screenModeExtentMinWidth
              );
              currentHeight = screenModeExtent.height;
            }
          }
        }
      }
    } else {
      const {
        height: chosenModeHeight,
        width: [chosenModeMinWidth, chosenModeMaxWidth]
      } = availableScreenModeExtents.find(
        (d3) => d3.mode === dashboardComponent.params.screenMode
      );
      currentMode = dashboardComponent.params.screenMode;
      currentWidth = Math.max(
        Math.min(chosenModeMaxWidth, dashboardComponent.containerWidth),
        chosenModeMinWidth
      );
      currentHeight = chosenModeHeight;
      if (dashboardComponent.params.itemEmbedding) {
        if (dashboardComponent.params.itemDimensions?.width && dashboardComponent.params.itemDimensions?.width !== "auto") {
          currentWidth = Number.parseInt(
            dashboardComponent.params.itemDimensions.width,
            10
          );
        }
        if (dashboardComponent.params.itemDimensions?.height && dashboardComponent.params.itemDimensions?.height !== "auto") {
          currentHeight = Number.parseInt(
            dashboardComponent.params.itemDimensions.height,
            10
          );
        }
      }
    }
    if (!currentMode && availableScreenModeExtents.length > 0) {
      const [lowestModeExtent] = availableScreenModeExtents;
      currentMode = lowestModeExtent.mode;
      currentWidth = lowestModeExtent.width[0];
      currentHeight = lowestModeExtent.height;
    }
  }
  dashboardComponent.currentScreenMode = currentMode;
  const style = {
    height: currentHeight === 0 ? "100%" : `${String(currentHeight)}px`,
    width: currentWidth === 0 ? "100%" : `${String(currentWidth)}px`,
    opacity: 1
  };
  const dashboardEditModes = ["editFull", "editLimited"];
  if (dashboardEditModes.includes(dashboardComponent.params.editMode)) {
    style.height = "100%";
    style.width = "100%";
  } else if (dashboardComponent.params.itemEmbedding && dashboardComponent.params.itemDimensions) {
    style.height = dashboardComponent.params.itemDimensions.height === "auto" ? style.height : `${String(dashboardComponent.params.itemDimensions.height).replace(
      "px",
      ""
    )}px`;
    style.width = dashboardComponent.params.itemDimensions.width === "auto" ? style.width : `${String(dashboardComponent.params.itemDimensions.width).replace(
      "px",
      ""
    )}px`;
  } else {
    style.height = currentHeight === 0 ? "100%" : `${String(currentHeight)}px`;
    style.width = currentWidth === 0 ? "100%" : `${String(currentWidth)}px`;
  }
  dashboardComponent.currentScreenMode = currentMode;
  dashboardComponent.iframeStyle = style;
};

// libs/embed-libs/shared-embed/src/lib/service/extend-and-validate.ts
var _extendAndValidate = (dashboardContent) => {
  const defaultKeys = Object.keys(
    DEFAULT_PARAMETERS
  );
  const errorMessages = [];
  const requiredStringParams = [
    "appServer",
    "language",
    "apiHost"
  ];
  const requiredStringOrEmptyParams = [
    "key",
    "token",
    "screenMode",
    "timezoneId",
    "itemId",
    "container",
    "loaderBackground",
    "loaderFontColor",
    "loaderSpinnerColor",
    "loaderSpinnerBackground"
  ];
  const objectParams = ["itemDimensions"];
  const screenModes = [
    "mobile",
    "tablet",
    "desktop",
    "largeScreen",
    "fixed",
    "auto"
  ];
  for (const key of defaultKeys) {
    if (dashboardContent.params[key] === null) {
      delete dashboardContent.params[key];
    }
  }
  dashboardContent.params = defaultsDeep(
    dashboardContent.params,
    DEFAULT_PARAMETERS
  );
  if ((!dashboardContent.params.dashboardId || typeof dashboardContent.params.dashboardId !== "string") && (!dashboardContent.params.dashboardSlug || typeof dashboardContent.params.dashboardSlug !== "string")) {
    delete dashboardContent.params.dashboardId;
    delete dashboardContent.params.dashboardSlug;
  }
  for (const key of requiredStringParams) {
    if (typeof dashboardContent.params[key] !== "string") {
      delete dashboardContent.params[key];
      errorMessages.push(`${key} needs to be of type string.`);
    }
  }
  for (const key of requiredStringOrEmptyParams) {
    if (typeof dashboardContent.params[key] !== "string" && dashboardContent.params[key] !== null && dashboardContent.params[key] !== void 0) {
      delete dashboardContent.params[key];
      errorMessages.push(`${key} needs to be of type string or empty.`);
    }
  }
  if (dashboardContent.params.screenMode && !screenModes.includes(dashboardContent.params.screenMode)) {
    const validTypesString = screenModes.map((mode) => `"${mode}"`).join(", ");
    errorMessages.push(
      `"screenMode" needs should be one of these types: ${validTypesString}`
    );
    dashboardContent.params.screenMode = "auto";
  }
  if (dashboardContent.params.itemId) {
    dashboardContent.params.itemEmbedding = true;
  }
  for (const key of objectParams) {
    if (typeof dashboardContent.params[key] !== "object" && dashboardContent.params[key] !== null) {
      delete dashboardContent.params[key];
      errorMessages.push(`${key} needs to be of type object or empty.`);
    }
  }
  if (typeof dashboardContent.params.switchScreenModeOnResize !== "boolean") {
    errorMessages.push("switchScreenModeOnResize needs to be of type boolean.");
    dashboardContent.params.switchScreenModeOnResize = true;
  }
  if (dashboardContent.params.itemDimensions) {
    const itemDimensionsKeys = [
      "width",
      "height"
    ];
    for (const key of itemDimensionsKeys) {
      if (!["string", "number"].includes(
        typeof dashboardContent.params.itemDimensions[key]
      ) && dashboardContent.params.itemDimensions[key] !== null) {
        errorMessages.push(
          `itemDimensions ${key} needs to be of type string, number or empty.`
        );
      }
    }
  }
  dashboardContent.params = defaultsDeep(
    dashboardContent.params,
    DEFAULT_PARAMETERS
  );
  if (dashboardContent.params.screenMode && dashboardContent.params.screenMode !== "auto") {
    dashboardContent.params.switchScreenModeOnResize = false;
  }
  if (dashboardContent.params.itemDimensions.width !== "auto") {
    dashboardContent.params.itemDimensions.width = Number.parseInt(
      `${dashboardContent.params.itemDimensions.width}`.replace("px", ""),
      10
    ) || "auto";
  }
  if (dashboardContent.params.itemDimensions.height !== "auto") {
    dashboardContent.params.itemDimensions.height = Number.parseInt(
      `${dashboardContent.params.itemDimensions.height}`.replace("px", ""),
      10
    ) || "auto";
  }
  dashboardContent.params.itemEmbedding = !!dashboardContent.params.itemId;
  if (dashboardContent.params.error || errorMessages.length > 0) {
    _handleError(errorMessages.join("\n"), dashboardContent.params);
  }
};

// node_modules/zod/lib/index.mjs
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
    const filtered = {};
    for (const k2 of validKeys) {
      filtered[k2] = obj[k2];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e7) {
      return obj[e7];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_2, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t5 = typeof data;
  switch (t5) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class _ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i6 = 0;
          while (i6 < issue.path.length) {
            const el = issue.path[i6];
            const terminal = i6 === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i6++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s4 of results) {
      if (s4.status === "aborted")
        return INVALID;
      if (s4.status === "dirty")
        status.dirty();
      arrayValue.push(s4.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x2) => x2.status === "aborted";
var isDirty = (x2) => x2.status === "dirty";
var isValid = (x2) => x2.status === "valid";
var isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
function __classPrivateFieldGet(receiver, state, kind, f3) {
  if (kind === "a" && !f3)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f3 : kind === "a" ? f3.call(receiver) : f3 ? f3.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f3) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f3)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f3.call(receiver, value) : f3 ? f3.value = value : state.set(receiver, value), value;
}
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache;
var _ZodNativeEnum_cache;
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i6) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i6));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i6) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i6));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a3, b3) {
  const aType = getParsedType(a3);
  const bType = getParsedType(b3);
  if (a3 === b3) {
    return { valid: true, data: a3 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b3);
    const sharedKeys = util.objectKeys(a3).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a3, ...b3 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a3[key], b3[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a3.length !== b3.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a3.length; index++) {
      const itemA = a3[index];
      const itemB = b3[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a3 === +b3) {
    return { valid: true, data: a3 };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i6) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i6)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e7) => {
          error.addIssue(makeArgsIssue(args, e7));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e7) => {
          error.addIssue(makeReturnsIssue(result, e7));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a3, b3) {
    return new _ZodPipeline({
      in: a3,
      out: b3,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function custom(check, params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        const p3 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p3.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        const p22 = typeof p3 === "string" ? { message: p3 } : p3;
        ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
      }
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// libs/embed-libs/shared-embed/src/lib/models/viz-item.model.ts
var slotsNameParser = z.enum([
  "y-axis",
  "measure",
  "legend",
  "x-axis",
  "evolution",
  "row",
  "column",
  "columns",
  "category",
  "target",
  "color",
  "geo",
  "route",
  "order",
  "source",
  "destination",
  "size",
  "name",
  "levels",
  "open",
  "high",
  "low",
  "close",
  "coordinates",
  "identifier"
]);
var slotParser = z.object({
  name: slotsNameParser,
  content: z.array(
    z.object({
      type: z.enum(["numeric", "hierarchy", "datetime", "spatial"]),
      format: z.string().optional(),
      label: z.union([z.string(), z.record(z.string())]).optional(),
      column: z.string().uuid().optional(),
      set: z.string().uuid().optional(),
      aggregationFunc: z.string().optional(),
      subtype: z.string().optional(),
      level: z.number().optional(),
      lowestLevel: z.number().optional(),
      currency: z.string().optional(),
      id: z.string().optional(),
      bins: z.object({
        enabled: z.boolean(),
        // eslint-disable-next-line id-blacklist
        number: z.number()
      }).optional()
    })
  )
});
var itemTypeParser = z.enum([
  "bar-chart",
  "column-chart",
  "area-chart",
  "one-number",
  "pivot-table",
  "textobject",
  "regular-table",
  "donut",
  "line-chart",
  "imageobject",
  "number-conditional",
  "combination-chart",
  "spacer",
  "boxplot",
  "circle-gauge",
  "treemap",
  "choropleth",
  "symbolmap",
  "routemap",
  "markermap",
  "hexbinmap",
  "heatmap",
  "spikemap",
  "heattable",
  "bullet",
  "funnel",
  "sunburst",
  "bubble-chart",
  "sankey",
  "scatter-plot",
  "speedometer",
  "circle-pack",
  "radar-chart",
  "pyramid",
  "parallel-coord",
  "ohlc",
  "strip-plot",
  "wordcloud",
  "videoobject",
  "venn-diagram"
]);
var slotsParser = z.array(slotParser);
var vizItemOptionsParser = z.object({
  title: z.record(z.string()).optional(),
  theme: z.union([z.string(), z.record(z.any())]).optional(),
  locale: z.string().optional(),
  html: z.record(z.string()).optional(),
  slices: z.record(z.any()).optional(),
  mode: z.string().optional(),
  url: z.string().optional(),
  bars: z.record(z.any()).optional(),
  manualValues: z.record(z.any()).optional(),
  measures: z.array(z.record(z.any())).optional(),
  classification: z.string().optional(),
  numberClasses: z.number().optional(),
  tileProvider: z.record(z.any()).optional(),
  vectorTileProvider: z.record(z.any()).optional(),
  sources: z.record(z.any()).optional(),
  display: z.union([z.record(z.any()), z.object({ title: z.boolean() })]).optional()
});
var canFilterParser = z.union([z.array(z.string()), z.literal("all")]);
var libraryTypeToWebComponentTypeMapping = {
  type: "type",
  theme: "theme",
  slots: "slots",
  options: "options",
  appServer: "app-server",
  apiHost: "api-host",
  authKey: "auth-key",
  authToken: "auth-token",
  contextId: "context-id",
  canFilter: "can-filter",
  filters: "filters"
};

// libs/embed-libs/shared-embed/src/lib/constants/class-constants.ts
var luzmoEmbedContainerClass = "luzmo-embed-container";

// libs/embed-libs/shared-embed/src/lib/helpers/remote-federation.ts
var remotesMap = {
  // "remote_app": { url: "http://localhost:4201/remoteEntry.mjs", format: "esm", from: "vite" },
};
var loadJS = async (url, fn) => {
  const resolvedUrl = typeof url === "function" ? await url() : url;
  const script = document.createElement("script");
  script.type = "text/javascript";
  script.addEventListener("load", fn);
  script.src = resolvedUrl;
  document.querySelectorAll("head")[0].append(script);
};
var wrapShareModule = (remoteFrom) => ({});
async function __federationMethodEnsure(remoteId) {
  const remote = remotesMap[remoteId];
  if (remote.inited) {
    return remote.lib;
  }
  if (remote.format === "var") {
    return new Promise((resolve) => {
      const callback = () => {
        if (!remote.inited) {
          remote.lib = window[remoteId];
          remote.lib.init(wrapShareModule(remote.from));
          remote.inited = true;
        }
        resolve(remote.lib);
      };
      return loadJS(remote.url, callback);
    });
  } else if (["esm", "systemjs"].includes(remote.format)) {
    return new Promise((resolve, reject) => {
      const getUrl = typeof remote.url === "function" ? remote.url : () => Promise.resolve(remote.url);
      getUrl().then((url) => {
        import(
          /* @vite-ignore */
          /* webpackIgnore: true */
          url
        ).then((lib) => {
          if (!remote.inited) {
            const shareScope = wrapShareModule(remote.from);
            lib.init(shareScope);
            remote.lib = lib;
            remote.lib.init(shareScope);
            remote.inited = true;
          }
          resolve(remote.lib);
        }).catch(reject);
      });
    });
  }
}
function __federationMethodWrapDefault(module2, need) {
  if (!(module2 == null ? void 0 : module2.default) && need) {
    const obj = /* @__PURE__ */ Object.create(null);
    obj.default = module2;
    obj.__esModule = true;
    return obj;
  }
  return module2;
}
async function __federationMethodGetRemote(remoteName, componentName) {
  return __federationMethodEnsure(remoteName).then((remote) => remote.get(componentName).then((factory) => factory()));
}
async function loadLibrary(appServer, componentName = "DashboardApp") {
  if (remotesMap[appServer]) {
    return remotesMap[appServer].module;
  }
  remotesMap[appServer] = {
    url: appServer?.startsWith("http://localhost") ? `${removeTrailingSlash(appServer)}/remoteEntry.mjs` : `${removeTrailingSlash(appServer)}/dashboard-app/remoteEntry.mjs`,
    format: "esm",
    from: "vite",
    module: void 0
  };
  const module2 = await __federationMethodGetRemote(appServer, `./${componentName}`);
  const wrappedModule = __federationMethodWrapDefault(module2, true);
  remotesMap[appServer].module = wrappedModule;
  return wrappedModule;
}

// node_modules/lit-html/lit-html.js
var t3 = globalThis;
var i3 = t3.trustedTypes;
var s2 = i3 ? i3.createPolicy("lit-html", { createHTML: (t5) => t5 }) : void 0;
var e5 = "$lit$";
var h2 = `lit$${(Math.random() + "").slice(9)}$`;
var o4 = "?" + h2;
var n4 = `<${o4}>`;
var r5 = document;
var l2 = () => r5.createComment("");
var c3 = (t5) => null === t5 || "object" != typeof t5 && "function" != typeof t5;
var a2 = Array.isArray;
var u2 = (t5) => a2(t5) || "function" == typeof t5?.[Symbol.iterator];
var d2 = "[ 	\n\f\r]";
var f2 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var v = /-->/g;
var _ = />/g;
var m = RegExp(`>|${d2}(?:([^\\s"'>=/]+)(${d2}*=${d2}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var p2 = /'/g;
var g = /"/g;
var $ = /^(?:script|style|textarea|title)$/i;
var y2 = (t5) => (i6, ...s4) => ({ _$litType$: t5, strings: i6, values: s4 });
var x = y2(1);
var b2 = y2(2);
var w = Symbol.for("lit-noChange");
var T = Symbol.for("lit-nothing");
var A = /* @__PURE__ */ new WeakMap();
var E = r5.createTreeWalker(r5, 129);
function C(t5, i6) {
  if (!Array.isArray(t5) || !t5.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return void 0 !== s2 ? s2.createHTML(i6) : i6;
}
var P = (t5, i6) => {
  const s4 = t5.length - 1, o6 = [];
  let r7, l3 = 2 === i6 ? "<svg>" : "", c4 = f2;
  for (let i7 = 0; i7 < s4; i7++) {
    const s5 = t5[i7];
    let a3, u3, d3 = -1, y3 = 0;
    for (; y3 < s5.length && (c4.lastIndex = y3, u3 = c4.exec(s5), null !== u3); )
      y3 = c4.lastIndex, c4 === f2 ? "!--" === u3[1] ? c4 = v : void 0 !== u3[1] ? c4 = _ : void 0 !== u3[2] ? ($.test(u3[2]) && (r7 = RegExp("</" + u3[2], "g")), c4 = m) : void 0 !== u3[3] && (c4 = m) : c4 === m ? ">" === u3[0] ? (c4 = r7 ?? f2, d3 = -1) : void 0 === u3[1] ? d3 = -2 : (d3 = c4.lastIndex - u3[2].length, a3 = u3[1], c4 = void 0 === u3[3] ? m : '"' === u3[3] ? g : p2) : c4 === g || c4 === p2 ? c4 = m : c4 === v || c4 === _ ? c4 = f2 : (c4 = m, r7 = void 0);
    const x2 = c4 === m && t5[i7 + 1].startsWith("/>") ? " " : "";
    l3 += c4 === f2 ? s5 + n4 : d3 >= 0 ? (o6.push(a3), s5.slice(0, d3) + e5 + s5.slice(d3) + h2 + x2) : s5 + h2 + (-2 === d3 ? i7 : x2);
  }
  return [C(t5, l3 + (t5[s4] || "<?>") + (2 === i6 ? "</svg>" : "")), o6];
};
var V = class _V {
  constructor({ strings: t5, _$litType$: s4 }, n6) {
    let r7;
    this.parts = [];
    let c4 = 0, a3 = 0;
    const u3 = t5.length - 1, d3 = this.parts, [f3, v2] = P(t5, s4);
    if (this.el = _V.createElement(f3, n6), E.currentNode = this.el.content, 2 === s4) {
      const t6 = this.el.content.firstChild;
      t6.replaceWith(...t6.childNodes);
    }
    for (; null !== (r7 = E.nextNode()) && d3.length < u3; ) {
      if (1 === r7.nodeType) {
        if (r7.hasAttributes())
          for (const t6 of r7.getAttributeNames())
            if (t6.endsWith(e5)) {
              const i6 = v2[a3++], s5 = r7.getAttribute(t6).split(h2), e7 = /([.?@])?(.*)/.exec(i6);
              d3.push({ type: 1, index: c4, name: e7[2], strings: s5, ctor: "." === e7[1] ? k : "?" === e7[1] ? H : "@" === e7[1] ? I : R }), r7.removeAttribute(t6);
            } else
              t6.startsWith(h2) && (d3.push({ type: 6, index: c4 }), r7.removeAttribute(t6));
        if ($.test(r7.tagName)) {
          const t6 = r7.textContent.split(h2), s5 = t6.length - 1;
          if (s5 > 0) {
            r7.textContent = i3 ? i3.emptyScript : "";
            for (let i6 = 0; i6 < s5; i6++)
              r7.append(t6[i6], l2()), E.nextNode(), d3.push({ type: 2, index: ++c4 });
            r7.append(t6[s5], l2());
          }
        }
      } else if (8 === r7.nodeType)
        if (r7.data === o4)
          d3.push({ type: 2, index: c4 });
        else {
          let t6 = -1;
          for (; -1 !== (t6 = r7.data.indexOf(h2, t6 + 1)); )
            d3.push({ type: 7, index: c4 }), t6 += h2.length - 1;
        }
      c4++;
    }
  }
  static createElement(t5, i6) {
    const s4 = r5.createElement("template");
    return s4.innerHTML = t5, s4;
  }
};
function N(t5, i6, s4 = t5, e7) {
  if (i6 === w)
    return i6;
  let h3 = void 0 !== e7 ? s4._$Co?.[e7] : s4._$Cl;
  const o6 = c3(i6) ? void 0 : i6._$litDirective$;
  return h3?.constructor !== o6 && (h3?._$AO?.(false), void 0 === o6 ? h3 = void 0 : (h3 = new o6(t5), h3._$AT(t5, s4, e7)), void 0 !== e7 ? (s4._$Co ??= [])[e7] = h3 : s4._$Cl = h3), void 0 !== h3 && (i6 = N(t5, h3._$AS(t5, i6.values), h3, e7)), i6;
}
var S2 = class {
  constructor(t5, i6) {
    this._$AV = [], this._$AN = void 0, this._$AD = t5, this._$AM = i6;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t5) {
    const { el: { content: i6 }, parts: s4 } = this._$AD, e7 = (t5?.creationScope ?? r5).importNode(i6, true);
    E.currentNode = e7;
    let h3 = E.nextNode(), o6 = 0, n6 = 0, l3 = s4[0];
    for (; void 0 !== l3; ) {
      if (o6 === l3.index) {
        let i7;
        2 === l3.type ? i7 = new M(h3, h3.nextSibling, this, t5) : 1 === l3.type ? i7 = new l3.ctor(h3, l3.name, l3.strings, this, t5) : 6 === l3.type && (i7 = new L(h3, this, t5)), this._$AV.push(i7), l3 = s4[++n6];
      }
      o6 !== l3?.index && (h3 = E.nextNode(), o6++);
    }
    return E.currentNode = r5, e7;
  }
  p(t5) {
    let i6 = 0;
    for (const s4 of this._$AV)
      void 0 !== s4 && (void 0 !== s4.strings ? (s4._$AI(t5, s4, i6), i6 += s4.strings.length - 2) : s4._$AI(t5[i6])), i6++;
  }
};
var M = class _M {
  get _$AU() {
    return this._$AM?._$AU ?? this._$Cv;
  }
  constructor(t5, i6, s4, e7) {
    this.type = 2, this._$AH = T, this._$AN = void 0, this._$AA = t5, this._$AB = i6, this._$AM = s4, this.options = e7, this._$Cv = e7?.isConnected ?? true;
  }
  get parentNode() {
    let t5 = this._$AA.parentNode;
    const i6 = this._$AM;
    return void 0 !== i6 && 11 === t5?.nodeType && (t5 = i6.parentNode), t5;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t5, i6 = this) {
    t5 = N(this, t5, i6), c3(t5) ? t5 === T || null == t5 || "" === t5 ? (this._$AH !== T && this._$AR(), this._$AH = T) : t5 !== this._$AH && t5 !== w && this._(t5) : void 0 !== t5._$litType$ ? this.$(t5) : void 0 !== t5.nodeType ? this.T(t5) : u2(t5) ? this.k(t5) : this._(t5);
  }
  S(t5) {
    return this._$AA.parentNode.insertBefore(t5, this._$AB);
  }
  T(t5) {
    this._$AH !== t5 && (this._$AR(), this._$AH = this.S(t5));
  }
  _(t5) {
    this._$AH !== T && c3(this._$AH) ? this._$AA.nextSibling.data = t5 : this.T(r5.createTextNode(t5)), this._$AH = t5;
  }
  $(t5) {
    const { values: i6, _$litType$: s4 } = t5, e7 = "number" == typeof s4 ? this._$AC(t5) : (void 0 === s4.el && (s4.el = V.createElement(C(s4.h, s4.h[0]), this.options)), s4);
    if (this._$AH?._$AD === e7)
      this._$AH.p(i6);
    else {
      const t6 = new S2(e7, this), s5 = t6.u(this.options);
      t6.p(i6), this.T(s5), this._$AH = t6;
    }
  }
  _$AC(t5) {
    let i6 = A.get(t5.strings);
    return void 0 === i6 && A.set(t5.strings, i6 = new V(t5)), i6;
  }
  k(t5) {
    a2(this._$AH) || (this._$AH = [], this._$AR());
    const i6 = this._$AH;
    let s4, e7 = 0;
    for (const h3 of t5)
      e7 === i6.length ? i6.push(s4 = new _M(this.S(l2()), this.S(l2()), this, this.options)) : s4 = i6[e7], s4._$AI(h3), e7++;
    e7 < i6.length && (this._$AR(s4 && s4._$AB.nextSibling, e7), i6.length = e7);
  }
  _$AR(t5 = this._$AA.nextSibling, i6) {
    for (this._$AP?.(false, true, i6); t5 && t5 !== this._$AB; ) {
      const i7 = t5.nextSibling;
      t5.remove(), t5 = i7;
    }
  }
  setConnected(t5) {
    void 0 === this._$AM && (this._$Cv = t5, this._$AP?.(t5));
  }
};
var R = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t5, i6, s4, e7, h3) {
    this.type = 1, this._$AH = T, this._$AN = void 0, this.element = t5, this.name = i6, this._$AM = e7, this.options = h3, s4.length > 2 || "" !== s4[0] || "" !== s4[1] ? (this._$AH = Array(s4.length - 1).fill(new String()), this.strings = s4) : this._$AH = T;
  }
  _$AI(t5, i6 = this, s4, e7) {
    const h3 = this.strings;
    let o6 = false;
    if (void 0 === h3)
      t5 = N(this, t5, i6, 0), o6 = !c3(t5) || t5 !== this._$AH && t5 !== w, o6 && (this._$AH = t5);
    else {
      const e8 = t5;
      let n6, r7;
      for (t5 = h3[0], n6 = 0; n6 < h3.length - 1; n6++)
        r7 = N(this, e8[s4 + n6], i6, n6), r7 === w && (r7 = this._$AH[n6]), o6 ||= !c3(r7) || r7 !== this._$AH[n6], r7 === T ? t5 = T : t5 !== T && (t5 += (r7 ?? "") + h3[n6 + 1]), this._$AH[n6] = r7;
    }
    o6 && !e7 && this.j(t5);
  }
  j(t5) {
    t5 === T ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t5 ?? "");
  }
};
var k = class extends R {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t5) {
    this.element[this.name] = t5 === T ? void 0 : t5;
  }
};
var H = class extends R {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t5) {
    this.element.toggleAttribute(this.name, !!t5 && t5 !== T);
  }
};
var I = class extends R {
  constructor(t5, i6, s4, e7, h3) {
    super(t5, i6, s4, e7, h3), this.type = 5;
  }
  _$AI(t5, i6 = this) {
    if ((t5 = N(this, t5, i6, 0) ?? T) === w)
      return;
    const s4 = this._$AH, e7 = t5 === T && s4 !== T || t5.capture !== s4.capture || t5.once !== s4.once || t5.passive !== s4.passive, h3 = t5 !== T && (s4 === T || e7);
    e7 && this.element.removeEventListener(this.name, this, s4), h3 && this.element.addEventListener(this.name, this, t5), this._$AH = t5;
  }
  handleEvent(t5) {
    "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t5) : this._$AH.handleEvent(t5);
  }
};
var L = class {
  constructor(t5, i6, s4) {
    this.element = t5, this.type = 6, this._$AN = void 0, this._$AM = i6, this.options = s4;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t5) {
    N(this, t5);
  }
};
var Z = t3.litHtmlPolyfillSupport;
Z?.(V, M), (t3.litHtmlVersions ??= []).push("3.1.2");
var j = (t5, i6, s4) => {
  const e7 = s4?.renderBefore ?? i6;
  let h3 = e7._$litPart$;
  if (void 0 === h3) {
    const t6 = s4?.renderBefore ?? null;
    e7._$litPart$ = h3 = new M(i6.insertBefore(l2(), t6), t6, void 0, s4 ?? {});
  }
  return h3._$AI(t5), h3;
};

// node_modules/lit-element/lit-element.js
var s3 = class extends b {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    const t5 = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t5.firstChild, t5;
  }
  update(t5) {
    const i6 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t5), this._$Do = j(i6, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this._$Do?.setConnected(true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._$Do?.setConnected(false);
  }
  render() {
    return w;
  }
};
s3._$litElement$ = true, s3["finalized", "finalized"] = true, globalThis.litElementHydrateSupport?.({ LitElement: s3 });
var r6 = globalThis.litElementPolyfillSupport;
r6?.({ LitElement: s3 });
(globalThis.litElementVersions ??= []).push("4.0.4");

// node_modules/lit-html/directive.js
var t4 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
var e6 = (t5) => (...e7) => ({ _$litDirective$: t5, values: e7 });
var i4 = class {
  constructor(t5) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t5, e7, i6) {
    this._$Ct = t5, this._$AM = e7, this._$Ci = i6;
  }
  _$AS(t5, e7) {
    return this.update(t5, e7);
  }
  update(t5, e7) {
    return this.render(...e7);
  }
};

// node_modules/lit-html/directives/style-map.js
var n5 = "important";
var i5 = " !" + n5;
var o5 = e6(class extends i4 {
  constructor(t5) {
    if (super(t5), t5.type !== t4.ATTRIBUTE || "style" !== t5.name || t5.strings?.length > 2)
      throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(t5) {
    return Object.keys(t5).reduce((e7, r7) => {
      const s4 = t5[r7];
      return null == s4 ? e7 : e7 + `${r7 = r7.includes("-") ? r7 : r7.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${s4};`;
    }, "");
  }
  update(e7, [r7]) {
    const { style: s4 } = e7.element;
    if (void 0 === this.ft)
      return this.ft = new Set(Object.keys(r7)), this.render(r7);
    for (const t5 of this.ft)
      null == r7[t5] && (this.ft.delete(t5), t5.includes("-") ? s4.removeProperty(t5) : s4[t5] = null);
    for (const t5 in r7) {
      const e8 = r7[t5];
      if (null != e8) {
        this.ft.add(t5);
        const r8 = "string" == typeof e8 && e8.endsWith(i5);
        t5.includes("-") || r8 ? s4.setProperty(t5, r8 ? e8.slice(0, -11) : e8, r8 ? n5 : "") : s4[t5] = e8;
      }
    }
    return w;
  }
});

// libs/embed-libs/embed/package.json
var version = "5.1.3-beta.3";

// libs/embed-libs/embed/src/lib/luzmo-service.ts
var LuzmoService = class {
  constructor() {
    this._components = [];
  }
};
var luzmo_service_default = new LuzmoService();

// libs/embed-libs/embed/src/lib/helper/event-bus-handler.ts
var _setEventHandler = () => {
  if (typeof window.__luzmoMessageHandler === "function") {
    return;
  }
  window.__luzmoMessageHandler = (event) => {
    const dashboardComponent = luzmo_service_default._components.find(
      (c4) => event.data.name === c4._iframeId
    );
    if (!dashboardComponent) {
      return;
    }
    switch (event.data?.type) {
      case "load": {
        dashboardComponent.dispatchEvent(
          new CustomEvent("load", { detail: { data: event.data } })
        );
        if (dashboardComponent._loadTimeoutHandle) {
          clearTimeout(dashboardComponent._loadTimeoutHandle);
          dashboardComponent._loadTimeoutHandle = void 0;
        }
        dashboardComponent.iframeLoaded = true;
        dashboardComponent.dimensions = event.data.dimensions;
        dashboardComponent._calculateDimAfterDashboardLoaded();
        break;
      }
      case "error": {
        dashboardComponent.dashboardError = true;
        if (dashboardComponent._loadTimeoutHandle) {
          clearTimeout(dashboardComponent._loadTimeoutHandle);
          dashboardComponent._loadTimeoutHandle = void 0;
        }
        dashboardComponent.iframeLoaded = true;
        dashboardComponent._displayError();
        console.error("Dashboard error: ", event.data.errorMsg);
        break;
      }
      case "data": {
        resolvePromise(
          dashboardComponent,
          event.data.requestId,
          event.data.data
        );
        break;
      }
      case "filters": {
        resolvePromise(
          dashboardComponent,
          event.data.requestId,
          event.data.filters
        );
        break;
      }
      case "getAccessibleDashboards": {
        resolvePromise(
          dashboardComponent,
          event.data.requestId,
          event.data.accessibleDashboards
        );
        break;
      }
      case "dashboardAction": {
        dashboardComponent.dispatchEvent(
          new CustomEvent("dashboardAction", { detail: { data: event.data } })
        );
        break;
      }
      case "export": {
        if (event.data.error) {
          rejectPromise(
            dashboardComponent,
            event.data.requestId,
            event.data
          );
        } else {
          dashboardComponent.dispatchEvent(
            new CustomEvent("exported", { detail: { data: event.data } })
          );
          resolvePromise(
            dashboardComponent,
            event.data.requestId,
            event.data
          );
        }
        break;
      }
      case "changedFilters": {
        dashboardComponent.dispatchEvent(
          new CustomEvent("changedFilters", { detail: { data: event.data } })
        );
        break;
      }
      case "customEvent": {
        dashboardComponent.dispatchEvent(
          new CustomEvent("customEvent", { detail: { data: event.data } })
        );
        break;
      }
      case "chartsRendered":
      case "itemsRendered": {
        event.data.type = "itemsRendered";
        dashboardComponent.dispatchEvent(
          new CustomEvent("itemsRendered", { detail: { data: event.data } })
        );
        break;
      }
      case "setEditMode": {
        if (event.data.error) {
          rejectPromise(
            dashboardComponent,
            event.data.requestId,
            event.data
          );
        } else {
          resolvePromise(
            dashboardComponent,
            event.data.requestId,
            event.data
          );
          dashboardComponent.params.editMode = event.data.editMode;
          dashboardComponent._containerStyle = containerStyles(dashboardComponent);
          if (dashboardComponent.dimensions) {
            _setCalculatedDimensions(dashboardComponent);
          }
        }
        break;
      }
      case "setFilters": {
        event.data.error ? rejectPromise(
          dashboardComponent,
          event.data.requestId,
          event.data
        ) : resolvePromise(
          dashboardComponent,
          event.data.requestId,
          event.data
        );
        break;
      }
      case "setPreview": {
        event.data.error ? rejectPromise(
          dashboardComponent,
          event.data.requestId,
          event.data
        ) : resolvePromise(
          dashboardComponent,
          event.data.requestId,
          event.data
        );
        break;
      }
    }
  };
  window.addEventListener("message", window.__luzmoMessageHandler, false);
};

// libs/embed-libs/embed/src/lib/dashboard-component/dashboard-styles.ts
var dashboardStyles = i`
  :host {
    display: block;
  }

  @-webkit-keyframes spin {
    0% {
      -webkit-transform: rotate(0deg);
      transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
      transform: rotate(360deg);
    }
  }

  @keyframes spin {
    0% {
      -webkit-transform: rotate(0deg);
      transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
      transform: rotate(360deg);
    }
  }
  :host {
    position: relative;
    width: 100%;
  }

  .luzmo-embed-dashboard {
    background: transparent;
    padding: 0;
    border: 0;
  }

  .luzmo-embed-container-ede {
    width: 100%;
    height: 100%;
  }

  .luzmo-container-loader {
    width: 100%;
    position: relative;
  }

  .luzmo-lc {
    margin: 0 auto;
  }

  .luzmo-loading-message {
    width: 100%;
    height: 20px;
    text-align: center;
    margin-bottom: 16px;
    font-family: Helvetica, Arial, sans-serif;
    font-size: 14px;
  }

  .luzmo-loading-circle {
    box-sizing: border-box;
    margin: 16px auto;
    position: relative;
    text-indent: -9999em;
    animation: spin 0.6s infinite linear;
  }

  .luzmo-loading-circle,
  .luzmo-loading-circle:after {
    border-radius: 50%;
    width: 32px;
    height: 32px;
  }

  .itemEmbedding:after {
    width: 24px;
    height: 24px;
  }

  .luzmo-error {
    background: transparent;
    padding: 48px 0;
    margin: 0 auto;
    width: 80%;
    border: 0;
    text-align: center;
    min-height: 192px;
  }

  .dashboard-error {
    font-size: 30px;
    background: transparent;
    padding: 48px 0;
    margin: 0 auto;
    width: 80%;
    border: 0;
    text-align: center;
    min-height: 192px;
  }

  .luzmo-loader {
    top: 0;
    left: 0;
    width: 100%;
    min-height: 400px;
    position: absolute;
    transition-duration: 0.3s;
  }
`;

// libs/embed-libs/embed/src/lib/dashboard-component/dashboard-base.ts
var LuzmoDashboard = class extends s3 {
  constructor() {
    super();
    this.language = "auto";
    this.screenMode = "auto";
    this.switchScreenModeOnResize = true;
    this.editMode = "view";
    this.experimental = false;
    this.iframeStyle = {};
    this._containerStyle = {};
    this._loaderStyle = {};
    this._lcStyle = {};
    this._loadingCircleStyle = {};
    this._containerLoaderStyle = {};
    this._loaderMsg = "";
    this._itemEmbedding = false;
    this.browserError = false;
    this.browserErrorMsg = "";
    this.dashboardError = false;
    this.browserNotSupported = [];
    this.libVersion = version + "-wc-luzmo";
    this.isLibraryLoaded = false;
    this.currentAuthKey = null;
    this.currentAuthToken = null;
    this.isInitCalled = false;
    this.attributesMap = {
      dashboardId: "dashboard-id",
      dashboardSlug: "dashboard-slug",
      itemId: "item-id",
      language: "language",
      qeVersion: "qe-version",
      screenMode: "screen-mode",
      switchScreenModeOnResize: "switch-screen-mode-on-resize",
      authKey: "auth-key",
      authToken: "auth-token",
      editMode: "edit-mode",
      mainColor: "main-color",
      accentColor: "accent-color",
      loaderBackground: "loader-background",
      loaderFontColor: "loader-font-color",
      loaderSpinnerColor: "loader-spinner-color",
      loaderSpinnerBackground: "loader-spinner-background",
      appServer: "app-server",
      apiHost: "api-host",
      itemDimensions: "item-dimensions",
      timezoneId: "timezone-id"
    };
    this.loaderSize = 32;
    this.borderWidth = 3;
    this.minHeight = 400;
    this._containerId = uuidv4();
    this._iframeId = `luzmo-dashboard-${this._containerId}`;
    this.iframeLoaded = false;
    this.promises = {};
    this.params = this._setOptions();
    this._onResize = () => {
      if (this.shadowRoot?.querySelector(".dashboard-container")) {
        this.containerWidth = this.luzmoEmbedContainer.offsetWidth;
        if (this.params.switchScreenModeOnResize && this.params.screenMode === "auto") {
          for (const d3 of EXTENTS) {
            if (d3.width[0] <= window.innerWidth && window.innerWidth <= d3.width[1]) {
              this.currentScreenMode = d3.mode;
            }
          }
        }
        if (this.iframeLoaded) {
          this._calculateDimAfterDashboardLoaded();
        } else {
          if (this.dimensions) {
            this.containerWidth = this.luzmoEmbedContainer.offsetWidth;
            _setCalculatedDimensions(this);
          }
        }
      }
    };
    this._resizeObserver = new ResizeObserver((entries) => {
      window.requestAnimationFrame(() => {
        if (!Array.isArray(entries) || entries.length === 0) {
          return;
        }
        this._onResize();
      });
    });
  }
  // Set resize event listener
  connectedCallback() {
    super.connectedCallback();
  }
  // Set resize event listener
  disconnectedCallback() {
    super.disconnectedCallback();
    this._resizeObserver.disconnect();
    for (const promiseKey of Object.keys(this.promises)) {
      this.promises[promiseKey].reject(
        new Error("Dashboard component was removed")
      );
    }
  }
  firstUpdated() {
    this._loaderMsg = getLoader(this)?.loadingMsg;
    this._loaderStyles();
    luzmo_service_default._components.push(this);
    if (this.luzmoEmbedContainer) {
      this._resizeObserver.observe(this.luzmoEmbedContainer);
    }
  }
  initComponent() {
    this.params = this._setOptions();
    if (this.getIsViewMode()) {
      loadLibrary(this.params.appServer).then(async () => {
        this.isLibraryLoaded = true;
        await this.updateComplete;
        const oldReference = this.renderRoot.querySelector("dashboard-component");
        this.dashboardReference = oldReference.cloneNode(true);
        oldReference.replaceWith(this.dashboardReference);
        this.dashboardReference.addEventListener("load", (payload) => {
          this.containerWidth = this.dashboardReference.offsetWidth;
          this.dimensions = payload.detail.dimensions;
          _setCalculatedDimensions(this);
          window.dispatchEvent(new Event("resize"));
          this.dispatchEvent(new CustomEvent("load", payload));
        });
        this.dashboardReference.addEventListener("itemsRendered", (payload) => this.dispatchEvent(new CustomEvent("itemsRendered", payload)));
        this.dashboardReference.addEventListener("customEvent", (payload) => this.dispatchEvent(new CustomEvent("customEvent", payload)));
        this.dashboardReference.addEventListener("changedFilters", (payload) => this.dispatchEvent(new CustomEvent("changedFilters", payload)));
        this.dashboardReference.addEventListener("dashboardAction", (payload) => this.dispatchEvent(new CustomEvent("dashboardAction", payload)));
        this.dashboardReference.addEventListener("export", (payload) => this.dispatchEvent(new CustomEvent("exported", payload)));
        this.setAllAttributes();
      });
    } else {
      this.containerWidth = this.container?.clientWidth;
      _extendAndValidate(this);
      _browserCheck(this);
      this._setupLoader();
      if (!this.params.error) {
        this._loaderStyles();
        _setEventHandler();
        this._iframeUrl = createIframeUrl(this);
        this.iframe?.setAttribute("src", this._iframeUrl);
        this.iframeStyle = calculateIframeStyles(this);
      }
    }
  }
  setAllAttributes() {
    if (this.dashboardReference) {
      for (const key in this.attributesMap) {
        if (!["authKey", "authToken", "apiHost", "itemDimensions"].includes(key) && this.params[key]) {
          this.dashboardReference.setAttribute(this.attributesMap[key], this.params[key]);
        }
        if (this.params.itemDimensions) {
          this.dashboardReference.setAttribute("item-dimensions", JSON.stringify(this.params.itemDimensions));
        }
        if (this.params.apiHost) {
          this.dashboardReference.setAttribute("api-host", removeTrailingSlash(this.params.apiHost));
        }
        if (this.params.key) {
          this.dashboardReference.setAttribute("auth-key", this.params.key);
        }
        if (this.params.token) {
          this.dashboardReference.setAttribute("auth-token", this.params.token);
        }
      }
    }
  }
  // Reload dashboard when triggerproperty changes
  updated(changedProperties) {
    const triggerProperties = /* @__PURE__ */ new Set([
      "dashboardId",
      "dashboardSlug",
      "itemId",
      "language",
      "qeVersion",
      "editMode",
      "screenMode",
      "switchScreenModeOnResize",
      "authToken",
      "authKey",
      "appServer",
      "timezoneId",
      "itemDimensions"
    ]);
    const conditionsToCheck = ["dashboardId", "dashboardSlug", "itemId"];
    let callInitComponent = false;
    for (const condition of conditionsToCheck) {
      callInitComponent = callInitComponent || changedProperties.get(condition) === void 0 && this[condition];
    }
    if (callInitComponent && !this.isInitCalled) {
      this.initComponent();
      this.isInitCalled = true;
      return;
    }
    if (this.getIsViewMode()) {
      if (this.dashboardReference) {
        for (const [propertyName] of changedProperties.entries()) {
          if (propertyName === "appSever") {
            loadLibrary(changedProperties[propertyName]).then(async () => {
              this.isLibraryLoaded = true;
              await this.updateComplete;
              this.dashboardReference = this.renderRoot.querySelector("dashboard-component");
              this.setAllAttributes();
            });
          } else if (this.attributesMap[propertyName]) {
            const mappedAttributeName = this.attributesMap[propertyName] ?? propertyName;
            const attributeValue = typeof this[propertyName] === "object" ? JSON.stringify(this[propertyName]) : this[propertyName]?.toString() || this[propertyName];
            this.dashboardReference.setAttribute(mappedAttributeName, attributeValue);
          }
        }
      }
    } else {
      for (const [propertyName] of changedProperties.entries()) {
        if (triggerProperties.has(propertyName) && propertyName !== "editMode") {
          this.iframeLoaded = false;
          if (this._loadTimeoutHandle) {
            clearTimeout(this._loadTimeoutHandle);
          }
          this._loadTimeoutHandle = setTimeout(() => {
            console.warn(
              "Failed to load dashboard, appServer is likely down or unreachable."
            );
          }, 15 * 1e3);
          this.params = this._setOptions();
          _extendAndValidate(this);
          this._setupLoader();
          this._loaderStyles();
          this._iframeUrl = createIframeUrl(this);
          if (this.iframe) {
            this._updateIframeUrl();
          }
          this.iframeStyle = calculateIframeStyles(this);
        } else if (triggerProperties.has(propertyName) && propertyName === "editMode") {
          if (this.iframeLoaded) {
            this.setEditMode(this.editMode);
          }
          this.params = this._setOptions();
        }
      }
    }
  }
  // Set params
  _setOptions() {
    const defaultParameters = {
      dashboardId: this.dashboardId,
      dashboardSlug: this.dashboardSlug
    };
    if (this.itemId) {
      defaultParameters.itemId = this.itemId;
      this._itemEmbedding = true;
    } else {
      this._itemEmbedding = false;
    }
    if (this.language) {
      defaultParameters.language = this.language;
    }
    if (this.qeVersion) {
      defaultParameters.qeVersion = this.qeVersion;
    }
    if (this.screenMode) {
      defaultParameters.screenMode = this.screenMode;
    }
    defaultParameters.switchScreenModeOnResize = this.switchScreenModeOnResize;
    if (this.authToken) {
      defaultParameters.token = this.authToken;
    }
    if (this.authKey) {
      defaultParameters.key = this.authKey;
    }
    if (this.editMode) {
      defaultParameters.editMode = this.editMode;
    }
    if (this.mainColor) {
      defaultParameters.mainColor = this.mainColor;
    }
    if (this.accentColor) {
      defaultParameters.accentColor = this.accentColor;
    }
    if (this.loaderBackground) {
      defaultParameters.loaderBackground = this.loaderBackground;
    }
    if (this.loaderFontColor) {
      defaultParameters.loaderFontColor = this.loaderFontColor;
    }
    if (this.loaderSpinnerColor) {
      defaultParameters.loaderSpinnerColor = this.loaderSpinnerColor;
    }
    if (this.loaderSpinnerBackground) {
      defaultParameters.loaderSpinnerBackground = this.loaderSpinnerBackground;
    }
    if (this.timezoneId) {
      defaultParameters.timezoneId = this.timezoneId;
    }
    if (this.itemDimensions) {
      defaultParameters.itemDimensions = this.itemDimensions;
    }
    if (this.appServer) {
      this.appServer = this.getIsViewMode() ? removeTrailingSlash(this.appServer) : addTrailingSlash(this.appServer);
      defaultParameters.appServer = this.appServer;
    } else {
      this.appServer = addTrailingSlash(
        DEFAULT_PARAMETERS.appServer
      );
      defaultParameters.appServer = this.appServer;
    }
    if (this.apiHost) {
      this.apiHost = this.getIsViewMode() ? removeTrailingSlash(this.apiHost) : addTrailingSlash(this.apiHost);
      defaultParameters.apiHost = this.apiHost;
    } else {
      this.apiHost = this.appServer.includes("luzmo.com") ? this.appServer.replace("app", "api") : this.appServer;
      defaultParameters.apiHost = this.apiHost;
    }
    this.currentAuthKey = this.authKey;
    this.currentAuthToken = this.authToken;
    return defaultParameters;
  }
  _updateIframeUrl() {
    updateIframeUrl(this.iframe, this._iframeUrl);
  }
  // Setup loader / browser error
  _setupLoader() {
    const data = getLoader(this);
    this._loaderMsg = data.loadingMsg;
    if (data.errorMsg) {
      this.browserError = true;
      this.browserErrorMsg = data.errorMsg;
      this._displayError();
    }
  }
  _displayError() {
    if (this.dashboardError) {
      this._loaderStyles();
      this.iframeStyle.opacity = 1;
    }
    if (this.browserError) {
      this._containerStyle.display = "none";
    }
  }
  _calculateDimAfterDashboardLoaded() {
    this.dashboardError = false;
    this._loaderStyles();
    _setCalculatedDimensions(this);
  }
  // Set loader styles
  _loaderStyles() {
    this._containerStyle = containerStyles(this);
    this._loaderStyle = loaderStyles(this);
    this._loadingCircleStyle = plStyles(this);
    this._containerLoaderStyle = containerLoaderStyles(this);
    this._lcStyle = lcStyles(this);
  }
  static get styles() {
    return [dashboardStyles];
  }
  render() {
    let toBeRenderedHTML;
    const loader = x`
      <div
        class="luzmo-container-loader"
        id="luzmo-container-loader-${this._containerId}"
        style=${o5(
      this._containerLoaderStyle
    )}
      >
        <div
          class="luzmo-loader"
          id="luzmo-loader-${this._containerId}"
          style=${o5(this._loaderStyle)}
        >
          <div
            class="luzmo-lc"
            style=${o5(this._lcStyle)}
          >
            <div
              class="luzmo-loading-circle"
              style=${o5(
      this._loadingCircleStyle
    )}
            ></div>
            ${this._itemEmbedding ? "" : x`
                <div
                  class="luzmo-loading-message"
                  style=${o5({ color: this.loaderFontColor })}
                >
                  ${this._loaderMsg}
                </div>
              `}
          </div>
        </div>
      </div>
    `;
    if (this.getIsViewMode()) {
      toBeRenderedHTML = this.isLibraryLoaded ? x`
          ${this.dashboardId || this.dashboardSlug ? x`
            <dashboard-component dashboard-id="${this.params.dashboardId}" app-server="${this.params.appServer}"
                                 api-host="${this.params.apiHost}"></dashboard-component>` : x`
            <div id="luzmo-error-${this._containerId}">
              <h3 class="luzmo-error">${this.browserErrorMsg}</h3>
            </div>
          `}
        ` : x`${loader}`;
    } else {
      toBeRenderedHTML = x`
        ${this.dashboardId || this.dashboardSlug ? x`
            ${loader}
            <iframe
              class="luzmo-embed-dashboard"
              id="${this._iframeId}"
              name="${this._iframeId}"
              style=${o5(this.iframeStyle)}
              src="${this._iframeUrl}"
              frameborder="0"
            ></iframe>
          ` : x`<!-- the dashboard will inititialize when you provide a dashboardSlug or a dashboardId -->`}
        ${this.browserError ? x`
            <div id="luzmo-error-${this._containerId}">
              <h3 class="luzmo-error">${this.browserErrorMsg}</h3>
            </div>
          ` : ""}
      `;
    }
    return x`
      <div class="${luzmoEmbedContainerClass} ${!this.getIsViewMode() ? `${luzmoEmbedContainerClass}-ede` : ""}">
        <div
          class="dashboard-container"
          style=${o5(Object.assign({}, this._containerStyle, {
      width: this.iframeStyle.width ?? "100%",
      height: this.iframeStyle.height ?? "100%"
    }))}
        >
          ${toBeRenderedHTML}
        </div>
      </div>

    `;
  }
  getDashboards() {
    return new Promise(
      (resolve) => resolve(luzmo_service_default._components)
    );
  }
  // Public methods
  getData(itemId) {
    if (this.getIsViewMode() && this.dashboardReference) {
      return this.dashboardReference.getData(itemId);
    }
    if (!this.getIsViewMode()) {
      return getData(this, this.iframe, itemId);
    }
    return Promise.reject();
  }
  getFilters() {
    if (this.getIsViewMode() && this.dashboardReference) {
      return this.dashboardReference.getFilters();
    }
    if (!this.getIsViewMode()) {
      return getFilters(this, this.iframe);
    }
    return Promise.reject();
  }
  setFilters(itemId, filters) {
    if (this.getIsViewMode() && this.dashboardReference) {
      return this.dashboardReference.setFilters(itemId, filters);
    }
    if (!this.getIsViewMode()) {
      return setFilters(this, this.iframe, itemId, filters);
    }
    return Promise.reject();
  }
  setAuthorization(key, token) {
    this.currentAuthKey = key;
    this.currentAuthToken = token;
    if (this.getIsViewMode() && this.dashboardReference) {
      return this.dashboardReference.setAuthorization(key, token);
    }
    if (!this.getIsViewMode()) {
      return setAuthorization(this, this.iframe, key, token);
    }
    return Promise.reject();
  }
  refreshData(itemId) {
    if (this.getIsViewMode() && this.dashboardReference) {
      return this.dashboardReference.refreshData(itemId);
    }
    if (!this.getIsViewMode()) {
      return itemId ? refreshData(this, this.iframe, itemId) : refreshData(this, this.iframe);
    }
    return Promise.reject();
  }
  reloadDashboard() {
    if (this.getIsViewMode() && this.dashboardReference) {
      return this.dashboardReference.reloadDashboard();
    }
    if (!this.getIsViewMode()) {
      return reloadDashboard(this, this.iframe);
    }
    return Promise.reject();
  }
  exportDashboard(format) {
    if (this.getIsViewMode() && this.dashboardReference) {
      return this.dashboardReference.exportDashboard(format);
    }
    if (!this.getIsViewMode()) {
      return format ? exportDashboard(this, this.iframe, format) : exportDashboard(this, this.iframe);
    }
    return Promise.reject();
  }
  getAccessibleDashboards() {
    return getAccessibleDashboards(this);
  }
  addFilters(itemId, filters) {
    return this.dashboardReference.addFilters(itemId, filters);
  }
  setEditMode(editMode) {
    if (this.dashboardReference && editMode === "view") {
      this.editMode = "view";
      this.params.editMode = "view";
      this.initComponent();
      return Promise.resolve({
        type: "setEditMode",
        editMode
      });
    }
    if (this.dashboardReference && ["editFull", "editLimited"].includes(editMode)) {
      this.editMode = editMode;
      this.params.editMode = editMode;
      this.initComponent();
      return Promise.resolve({
        type: "setEditMode",
        editMode
      });
    }
    if (this.getIsViewMode() && this.dashboardReference) {
      return this.dashboardReference.setEditMode(editMode);
    }
    if (!this.getIsViewMode()) {
      return setEditMode(this, this.iframe, editMode);
    }
    return Promise.reject();
  }
  setPreview(preview) {
    if (this.getIsViewMode() && this.dashboardReference) {
      return this.dashboardReference.setPreview(preview);
    }
    return setPreview(this, this.iframe, preview);
  }
  getIsViewMode() {
    return this.experimental && this.params.editMode === "view" || this.params.editMode === void 0;
  }
};
__decorateClass([
  e4(".dashboard-container")
], LuzmoDashboard.prototype, "container", 2);
__decorateClass([
  e4(`.${luzmoEmbedContainerClass}`)
], LuzmoDashboard.prototype, "luzmoEmbedContainer", 2);
__decorateClass([
  e4("iframe")
], LuzmoDashboard.prototype, "iframe", 2);
__decorateClass([
  n3()
], LuzmoDashboard.prototype, "dashboardId", 2);
__decorateClass([
  n3()
], LuzmoDashboard.prototype, "dashboardSlug", 2);
__decorateClass([
  n3()
], LuzmoDashboard.prototype, "itemId", 2);
__decorateClass([
  n3()
], LuzmoDashboard.prototype, "language", 2);
__decorateClass([
  n3()
], LuzmoDashboard.prototype, "qeVersion", 2);
__decorateClass([
  n3()
], LuzmoDashboard.prototype, "screenMode", 2);
__decorateClass([
  n3({
    converter: {
      fromAttribute: (value) => value === "true",
      toAttribute: String
    }
  })
], LuzmoDashboard.prototype, "switchScreenModeOnResize", 2);
__decorateClass([
  n3()
], LuzmoDashboard.prototype, "editMode", 2);
__decorateClass([
  n3()
], LuzmoDashboard.prototype, "mainColor", 2);
__decorateClass([
  n3()
], LuzmoDashboard.prototype, "accentColor", 2);
__decorateClass([
  n3()
], LuzmoDashboard.prototype, "authToken", 2);
__decorateClass([
  n3()
], LuzmoDashboard.prototype, "authKey", 2);
__decorateClass([
  n3()
], LuzmoDashboard.prototype, "loaderBackground", 2);
__decorateClass([
  n3()
], LuzmoDashboard.prototype, "loaderFontColor", 2);
__decorateClass([
  n3()
], LuzmoDashboard.prototype, "loaderSpinnerColor", 2);
__decorateClass([
  n3()
], LuzmoDashboard.prototype, "loaderSpinnerBackground", 2);
__decorateClass([
  n3()
], LuzmoDashboard.prototype, "appServer", 2);
__decorateClass([
  n3()
], LuzmoDashboard.prototype, "timezoneId", 2);
__decorateClass([
  n3()
], LuzmoDashboard.prototype, "apiHost", 2);
__decorateClass([
  n3({ type: Object })
], LuzmoDashboard.prototype, "itemDimensions", 2);
__decorateClass([
  n3({
    converter: {
      fromAttribute: (value) => value === "true",
      toAttribute: String
    }
  })
], LuzmoDashboard.prototype, "experimental", 2);
__decorateClass([
  n3({ attribute: false })
], LuzmoDashboard.prototype, "_containerId", 2);
__decorateClass([
  n3({ attribute: false })
], LuzmoDashboard.prototype, "_iframeId", 2);
__decorateClass([
  n3({ attribute: false })
], LuzmoDashboard.prototype, "params", 2);
__decorateClass([
  n3({ attribute: false })
], LuzmoDashboard.prototype, "_iframeUrl", 2);
__decorateClass([
  n3({ attribute: false })
], LuzmoDashboard.prototype, "iframeLoaded", 2);
__decorateClass([
  n3({ attribute: false })
], LuzmoDashboard.prototype, "promises", 2);
__decorateClass([
  n3({ attribute: false })
], LuzmoDashboard.prototype, "iframeStyle", 2);
__decorateClass([
  n3({ attribute: false })
], LuzmoDashboard.prototype, "_containerStyle", 2);
__decorateClass([
  n3({ attribute: false })
], LuzmoDashboard.prototype, "_loaderStyle", 2);
__decorateClass([
  n3({ attribute: false })
], LuzmoDashboard.prototype, "_lcStyle", 2);
__decorateClass([
  n3({ attribute: false })
], LuzmoDashboard.prototype, "_loadingCircleStyle", 2);
__decorateClass([
  n3({ attribute: false })
], LuzmoDashboard.prototype, "_containerLoaderStyle", 2);
__decorateClass([
  n3({ attribute: false })
], LuzmoDashboard.prototype, "_loaderMsg", 2);
__decorateClass([
  n3({ attribute: false })
], LuzmoDashboard.prototype, "containerWidth", 2);
__decorateClass([
  n3({ attribute: false })
], LuzmoDashboard.prototype, "dimensions", 2);
__decorateClass([
  n3({ attribute: false })
], LuzmoDashboard.prototype, "currentScreenMode", 2);
__decorateClass([
  n3({ attribute: false })
], LuzmoDashboard.prototype, "_itemEmbedding", 2);
__decorateClass([
  n3({ attribute: false })
], LuzmoDashboard.prototype, "browserError", 2);
__decorateClass([
  n3({ attribute: false })
], LuzmoDashboard.prototype, "browserErrorMsg", 2);
__decorateClass([
  n3({ attribute: false })
], LuzmoDashboard.prototype, "dashboardError", 2);
__decorateClass([
  n3({ attribute: false })
], LuzmoDashboard.prototype, "browserNotSupported", 2);
__decorateClass([
  n3()
], LuzmoDashboard.prototype, "libVersion", 2);
__decorateClass([
  r4()
], LuzmoDashboard.prototype, "isLibraryLoaded", 2);
__decorateClass([
  r4()
], LuzmoDashboard.prototype, "dashboardReference", 2);
__decorateClass([
  r4()
], LuzmoDashboard.prototype, "currentAuthKey", 2);
__decorateClass([
  r4()
], LuzmoDashboard.prototype, "currentAuthToken", 2);
__decorateClass([
  r4()
], LuzmoDashboard.prototype, "isInitCalled", 2);

// libs/embed-libs/embed/src/lib/dashboard-component/dashboard-component.ts
var LuzmoDashboard2 = class extends LuzmoDashboard {
};
LuzmoDashboard2 = __decorateClass([
  t("luzmo-dashboard")
], LuzmoDashboard2);
var LuzmoEmbedDashboard = class extends LuzmoDashboard {
};
LuzmoEmbedDashboard = __decorateClass([
  t("luzmo-embed-dashboard")
], LuzmoEmbedDashboard);

// node_modules/zod-validation-error/dist/index.mjs
var ValidationError = class extends Error {
  name;
  details;
  constructor(message, options) {
    super(message, options);
    this.name = "ZodValidationError";
    this.details = getIssuesFromErrorOptions(options);
  }
  toString() {
    return this.message;
  }
};
function getIssuesFromErrorOptions(options) {
  if (options) {
    const cause = options.cause;
    if (cause instanceof ZodError) {
      return cause.issues;
    }
  }
  return [];
}
var ISSUE_SEPARATOR = "; ";
var MAX_ISSUES_IN_MESSAGE = 99;
var PREFIX = "Validation error";
var PREFIX_SEPARATOR = ": ";
var UNION_SEPARATOR = ", or ";
function prefixMessage(message, prefix, prefixSeparator) {
  if (prefix !== null) {
    if (message.length > 0) {
      return [prefix, message].join(prefixSeparator);
    }
    return prefix;
  }
  if (message.length > 0) {
    return message;
  }
  return PREFIX;
}
var identifierRegex = /[$_\p{ID_Start}][$\u200c\u200d\p{ID_Continue}]*/u;
function joinPath(path) {
  if (path.length === 1) {
    return path[0].toString();
  }
  return path.reduce((acc, item) => {
    if (typeof item === "number") {
      return acc + "[" + item.toString() + "]";
    }
    if (item.includes('"')) {
      return acc + '["' + escapeQuotes(item) + '"]';
    }
    if (!identifierRegex.test(item)) {
      return acc + '["' + item + '"]';
    }
    const separator = acc.length === 0 ? "" : ".";
    return acc + separator + item;
  }, "");
}
function escapeQuotes(str) {
  return str.replace(/"/g, '\\"');
}
function isNonEmptyArray(value) {
  return value.length !== 0;
}
function getMessageFromZodIssue(props) {
  const { issue, issueSeparator, unionSeparator, includePath } = props;
  if (issue.code === "invalid_union") {
    return issue.unionErrors.reduce((acc, zodError) => {
      const newIssues = zodError.issues.map(
        (issue2) => getMessageFromZodIssue({
          issue: issue2,
          issueSeparator,
          unionSeparator,
          includePath
        })
      ).join(issueSeparator);
      if (!acc.includes(newIssues)) {
        acc.push(newIssues);
      }
      return acc;
    }, []).join(unionSeparator);
  }
  if (issue.code === "invalid_arguments") {
    return [
      issue.message,
      ...issue.argumentsError.issues.map(
        (issue2) => getMessageFromZodIssue({
          issue: issue2,
          issueSeparator,
          unionSeparator,
          includePath
        })
      )
    ].join(issueSeparator);
  }
  if (issue.code === "invalid_return_type") {
    return [
      issue.message,
      ...issue.returnTypeError.issues.map(
        (issue2) => getMessageFromZodIssue({
          issue: issue2,
          issueSeparator,
          unionSeparator,
          includePath
        })
      )
    ].join(issueSeparator);
  }
  if (includePath && isNonEmptyArray(issue.path)) {
    if (issue.path.length === 1) {
      const identifier = issue.path[0];
      if (typeof identifier === "number") {
        return `${issue.message} at index ${identifier}`;
      }
    }
    return `${issue.message} at "${joinPath(issue.path)}"`;
  }
  return issue.message;
}
function fromZodError(zodError, options = {}) {
  if (!(zodError instanceof ZodError)) {
    throw new TypeError(
      `Invalid zodError param; expected instance of ZodError. Did you mean to use the "${fromError.name}" method instead?`
    );
  }
  const {
    maxIssuesInMessage = MAX_ISSUES_IN_MESSAGE,
    issueSeparator = ISSUE_SEPARATOR,
    unionSeparator = UNION_SEPARATOR,
    prefixSeparator = PREFIX_SEPARATOR,
    prefix = PREFIX,
    includePath = true
  } = options;
  const zodIssues = zodError.errors;
  const reason = zodIssues.length === 0 ? zodError.message : zodIssues.slice(0, maxIssuesInMessage).map(
    (issue) => getMessageFromZodIssue({
      issue,
      issueSeparator,
      unionSeparator,
      includePath
    })
  ).join(issueSeparator);
  const message = prefixMessage(reason, prefix, prefixSeparator);
  return new ValidationError(message, { cause: zodError });
}
var toValidationError = (options = {}) => (err) => {
  if (err instanceof ZodError) {
    return fromZodError(err, options);
  }
  if (err instanceof Error) {
    return new ValidationError(err.message, { cause: err });
  }
  return new ValidationError("Unknown error");
};
function fromError(err, options = {}) {
  return toValidationError(options)(err);
}

// libs/embed-libs/embed/src/lib/viz-item/viz-item.base.ts
var LuzmoBaseVizItem = class extends s3 {
  constructor() {
    super();
    this.appServer = "https://app.luzmo.com";
    this.apiHost = "https://api.luzmo.com";
    this.slots = [];
    this.options = {
      title: {
        en: ""
      },
      theme: "default"
    };
    this.version = version + "-wc-luzmo";
  }
  static {
    // Static styles to set host display to block, else it is not shown at all for some reason.
    this.styles = i`
    :host {
      display: block;
      width: 100%;
      height: 100%;
    }
  `;
  }
  async firstUpdated(_changedProperties) {
    super.firstUpdated(_changedProperties);
    if (this.type) {
      await loadLibrary(this.appServer, "DashboardApp");
      this.createAndAppendElement();
    }
  }
  createAndAppendElement() {
    if (!this.chartElement) {
      this.chartElement = document.createElement("chart-component");
      this.chartElement.setAttribute("embedding-mode", "chart");
      this.updateVizItemProperties();
      this.renderRoot.append(this.chartElement);
    }
  }
  updateVizItemProperties() {
    if (this.chartElement) {
      for (const key in libraryTypeToWebComponentTypeMapping) {
        const value = this[key];
        if (value) {
          this.parseAndValidate(key);
          const attributeValue = ["appServer", "apiHost"].includes(key) ? removeTrailingSlash(value) : value;
          this.chartElement.setAttribute(
            libraryTypeToWebComponentTypeMapping[key],
            typeof attributeValue === "object" ? JSON.stringify(attributeValue) : attributeValue
          );
        }
      }
    }
  }
  async updated(changedProperties) {
    if (this.chartElement) {
      for (const [propertyName] of changedProperties.entries()) {
        const mappedAttributeName = libraryTypeToWebComponentTypeMapping[propertyName] ?? propertyName;
        this.parseAndValidate(propertyName);
        const attributeValue = typeof this[propertyName] === "object" ? JSON.stringify(this[propertyName]) : this[propertyName]?.toString() ?? this[propertyName];
        this.chartElement.setAttribute(mappedAttributeName, attributeValue);
      }
    } else {
      if (this.type) {
        this.parseAndValidate("type");
        await loadLibrary(this.appServer, "DashboardApp");
        this.createAndAppendElement();
      }
    }
  }
  parseAndValidate(key) {
    try {
      if (key === "slots") {
        slotsParser.parse(this.slots);
      } else if (key === "options") {
        vizItemOptionsParser.parse(this.options);
      } else if (key === "canFilter") {
        canFilterParser.parse(this.canFilter);
      } else if (key === "type") {
        itemTypeParser.parse(this.type);
      }
    } catch (err) {
      const validationError = fromError(err);
      console.error(err);
      console.error(validationError.toString());
    }
  }
  render() {
    return x`  `;
  }
};
__decorateClass([
  n3()
], LuzmoBaseVizItem.prototype, "appServer", 2);
__decorateClass([
  n3()
], LuzmoBaseVizItem.prototype, "apiHost", 2);
__decorateClass([
  n3({ type: Array })
], LuzmoBaseVizItem.prototype, "slots", 2);
__decorateClass([
  n3({ type: Object })
], LuzmoBaseVizItem.prototype, "options", 2);
__decorateClass([
  n3()
], LuzmoBaseVizItem.prototype, "type", 2);
__decorateClass([
  n3()
], LuzmoBaseVizItem.prototype, "authKey", 2);
__decorateClass([
  n3()
], LuzmoBaseVizItem.prototype, "authToken", 2);
__decorateClass([
  n3()
], LuzmoBaseVizItem.prototype, "version", 2);
__decorateClass([
  n3()
], LuzmoBaseVizItem.prototype, "contextId", 2);
__decorateClass([
  n3({
    converter: (value) => {
      try {
        return JSON.parse(value);
      } catch (exc) {
        return value;
      }
    }
  })
], LuzmoBaseVizItem.prototype, "canFilter", 2);
__decorateClass([
  n3({ type: Array })
], LuzmoBaseVizItem.prototype, "filters", 2);

// libs/embed-libs/embed/src/lib/viz-item/viz-item-component.ts
var LuzmoVizItem = class extends LuzmoBaseVizItem {
};
LuzmoVizItem = __decorateClass([
  t("luzmo-viz-item")
], LuzmoVizItem);
/*! Bundled license information:

@lit/reactive-element/decorators/custom-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/reactive-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/property.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/state.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/event-options.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/base.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-all.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-async.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-elements.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-nodes.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/style-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
if (typeof module.exports == "object" && typeof exports == "object") {
  var __cp = (to, from, except, desc) => {
    if ((from && typeof from === "object") || typeof from === "function") {
      for (let key of Object.getOwnPropertyNames(from)) {
        if (!Object.prototype.hasOwnProperty.call(to, key) && key !== except)
        Object.defineProperty(to, key, {
          get: () => from[key],
          enumerable: !(desc = Object.getOwnPropertyDescriptor(from, key)) || desc.enumerable,
        });
      }
    }
    return to;
  };
  module.exports = __cp(module.exports, exports);
}
return module.exports;
}))
